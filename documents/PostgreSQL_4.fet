SPItemBegin [keep format] = Alter Attribute
/* DESCRIPTION: Alter an attribute during alter scrpit generation.     */
/* Assumes the context object is an attribute.                         */ 
[
	PushOwner
	@if ( Equal( ObjectType, "Entity" ) )
	{
		Pop
		/* Current context is an attribute. */

		ShouldGenerate

		/* Column name. */
		[ IsPropertyModified( "Physical_Name", "Name" )
			NotEqual( [ PushOldImage Property( "Physical_Name" ) Pop ], Property( "Physical_Name" ) )
			FE::Bucket( "30" )
			PushOwner
			FE::RecordAlter
			"ALTER TABLE " [ FE::OwnerOverride ( "true" ) "." ] QuotedName
			Pop
			"\nRENAME COLUMN " PushOldImage QuotedName Pop " TO " QuotedName
			FE::EndOfStatement
		]
 
		/* Datatype, Character Semantics and Null Option. */
		SetLocalFlag( "Use Alter" )
		@if ( IsPropertyModified( "Physical_Data_Type" ) )
		{
			SetLocalFlag( "Data Type Modified" )
			@ifnot ( AllowAlterDatatype )
			{

				/* Drop-recreate the entity if column datatype cannot be modified */
				/* unless "force alter syntax" option is turned on.               */
				[ FE::Option( "!AlterStatements" )
						ClearLocalFlag( "Use Alter" )
				]
			}
		}
		@if ( IsPropertyModified( "Character_Semantics_Type" ) )
		{
			SetLocalFlag( "Data Type Modified" )
		}
		@if ( IsPropertyModified( "Null_Option_Type" ) )
		{
			SetLocalFlag( "Data Type Modified" )
		}

		[ IsLocalFlagSet( "Data Type Modified" )
			@if ( IsLocalFlagSet( "Use Alter" ) )
			{
				@ifnot( IsCreated )
				{     
					@if ( IsPropertyModified( "Null_Option_Type" ) ) 
					{
						/* Drop-recreate entity if null option was changed to NOT NULL */
						/* unless "force alter syntax" option is turned on.            */
						[ FE::Option( "!AlterStatements" )
							IsPropertyEqual( "Null_Option_Type", "1" )
							PushTopLevelObject
							[ Execute( "Generate Entity" ) ]
							Pop
						]
					}

					PushOwner

					FE::Bucket( "40" ) "\n"
					FE::RecordAlter
					"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop
					" MODIFY("  QuotedName  " "
					@if ( IsPropertyNull ( "Character_Semantics_Type" ) )
					{
						Property( "Physical_Data_Type" )
					}
					@else
					{
						/* Remove closing braces. */
						Substitute( Property( "Physical_Data_Type" ), "", ")" ) " "
						LookupProperty( "Character_Semantics_Type", "907", "BYTE", "908", "CHAR" )
						/* Append closing braces if needed. */
						[ NotEqual( Property( "Physical_Data_Type" ), Substitute( Property( "Physical_Data_Type" ), "", ")" ) )  ")" ]
					}
					[ LookupProperty( "Time_Zone_Option", "904", " WITH TIME ZONE", "905", " WITH LOCAL TIME ZONE" ) ]
					[ " " @if ( IsPropertyModified( "Null_Option_Type" ) ) { LookupProperty( "Null_Option_Type", "0", "NULL", "1", "NOT NULL" )} ]
					")"
					FE::EndOfStatement
				}
			}
			@else
			{
				/* Cannot alter this datatype. Re-create the entity. */
				PushOwner
				Execute( "Generate Entity" )
				Pop
			}
		]

		Remove( "Use Alter" )
		Remove( "Data Type Modified" )
	
		/* Column comments. */
		[ IsPropertyModified( "Comment", "Definition" )
			ShouldGenerate
			FE::Option( "Comments" )				
			FE::Bucket( "90" )
			FE::RecordAlter
			IsOwnerPropertyNotEqual( "Data_Organization_Type", "913", "true" )
			"COMMENT ON COLUMN "
			[ FE::OwnerOverride( "true", "1" ) "." ]
			OwnerQuotedName "." QuotedName
			" IS '" <Substitute( Left( Property( "Comment" ), "4000" ), "''", "'" )>  "'"
			FE::EndOfStatement
		]
	
		/* Attribute unification/de-unification */
		[ IsPropertyModified( "Physical_Lead_Attribute_Ref" )
			PushTopLevelObject
			[
				Execute( "Generate " ObjectType )
			]
			Pop
		]

		/* Is any property other than the null option, name, or comment was modified? */
		[ FE::IsModified ( "Physical_Data_Type", "Character_Semantics_Type", "Physical_Name", "Null_Option_Type", 
						"Name", "Comment", "Definition", "Logical_Datatype" )
			/* Recreate the entity. */
			PushTopLevelObject
			[ Execute ( "Generate " ObjectType ) ]
			Pop
		]
	}
	@elseif ( Equal( ObjectType, "View" ) )
	{       
		Pop

		/* The current context is an attribute. */

		ShouldGenerate

		/* View attribute comment. */
		[ IsPropertyModified( "Definition" )
			FE::Option( "Comments" )
			FE::Bucket( "90" )
			FE::RecordAlter
			PushOwner
			"COMMENT ON COLUMN " [ FE::OwnerOverride( "true" ) "." ]  QuotedName "." 
			Pop
			QuotedName
			" IS '" < Substitute( Left( Property( "Definition" ), "4000" ), "''", "'" ) >  "'"
			FE::EndOfStatement
		]
		
		/* Was any attribute property other than defintion modified? */
		[ FE::IsModified( "Definition" )
		
			/* Recreate the view. */
			PushTopLevelObject
			[ Execute( "Generate " ObjectType ) ]
			Pop
		]
	}
	@elseif( Equal( ObjectType, "Cached_View" ) )
	{
		Pop

		/* The current context is an attribute. */

		ShouldGenerate

		/* View attribute comment. */
		[ IsPropertyModified( "Definition" )
			FE::Option( "Comments" )
			FE::Bucket( "90" )
			FE::RecordAlter
			PushOwner
			"COMMENT ON COLUMN " [ FE::OwnerOverride( "true" ) "." ]  QuotedName "." 
			Pop
			QuotedName
			" IS '" < Substitute( Left( Property( "Definition" ), "4000" ), "''", "'" ) >  "'"
			FE::EndOfStatement
		]
		
		/* Was any attribute property other than defintion modified? */
		[ FE::IsModified( "Definition" )
		
			/* Recreate the view. */
			PushTopLevelObject
			[ Execute( "Generate " ObjectType ) ]
			Pop
		]
	}
	@else
	{
		Pop
	}

]
SPItemEnd

SPItemBegin [keep format] = Alter Cached_View
/* DESCRIPTION: Alter a cached view during alter script generation. */
/* Assumes the context object is a cached view.                     */
[ ShouldGenerate
	/* View name changed, emit rename view statement. */
	[ IsPropertyModified( "Name" )
		NotEqual( [ PushOldImage Property( "Name" ) Pop ], Property( "Name" ) )
		@ifnot ( IsPropertyModified( "Schema_Name" ) )
		{
			FE::Bucket( "30" )
			FE::RecordAlter
			"RENAME " PushOldImage QuotedName Pop
			" TO " QuotedName
			FE::EndOfStatement
		}
	]

	/* Comments. */
	[ IsPropertyModified( "Definition" ) FE::Option( "Comments" )
		/* Generate the table-level comment.    */
		[ DBMSVersion( "8", "9" )
			FE::Bucket( "90" )
			FE::RecordAlter
			"COMMENT ON TABLE "
			[ FE::OwnerOverride( "true" ) "." ] QuotedName
			" IS '" < Substitute( Left( Property( "Definition" ), "4000" ), "''", "'" ) >  "'"
			FE::EndOfStatement  
		]
		[ DBMSVersion( "10" )
			FE::Bucket( "90" )
			FE::RecordAlter
			"COMMENT ON MATERIALIZED VIEW  "
			[ FE::OwnerOverride( "true" ) "." ] QuotedName
			" IS '" < Substitute( Left( Property( "Definition" ), "4000" ), "''", "'" ) >  "'"
			FE::EndOfStatement  		
		]
	]

	/* Was any property other than the name or comment modified? */
	[ FE::IsModified( "Name", "Definition" )
		/* Recreate the view. */
		Execute( "Generate Cached_View" )
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Check_Constraint_Usage
/* DESCRIPTION: Alter a check constraint usage during alter script generation.   */
/* Assumes the context object is a check constraint usage.                        */
[
	PushOwner
	@if ( Equal( ObjectType, "Attribute" ) )
	{
		/* Column-level check constraint. */
		Pop

		[ ShouldGenerate
			IsPropertyModified( "Physical_Name", "Name" )
			NotEqual( [ PushOldImage Property( "Physical_Name" ) Pop ], Property( "Physical_Name" ) )
			FE::Bucket( "30" ) "\n"
			PushOwner
			PushOwner
			FE::RecordAlter
			"ALTER TABLE "
			[ FE::OwnerOverride( "true" ) "." ] QuotedName
			Pop
			Pop
			" RENAME CONSTRAINT "  Execute( "Previous Physical Name" )  " TO " QuotedName
			FE::EndOfStatement
		]
	
		[ FE::IsModified( "Physical_Name", "Name" )
			Execute( "Drop Check_Constraint_Usage" )
			Execute( "Create Check_Constraint_Usage" )
		]
	}
	@elseif( Equal( ObjectType, "Entity" ) )
	{
		/* Table-level check consstraint. */
		Pop

		[ ShouldGenerate
			IsPropertyModified( "Physical_Name", "Name" )
			NotEqual( [ PushOldImage Property( "Physical_Name" ) Pop ], Property( "Physical_Name" ) )
			FE::Bucket( "30" ) "\n"
			PushOwner
			FE::RecordAlter
			"ALTER TABLE "
			[ FE::OwnerOverride( "true" ) "." ] QuotedName
			Pop
			" RENAME CONSTRAINT "  Execute( "Previous Physical Name" ) "  TO " QuotedName
			FE::EndOfStatement
		]

		[ FE::IsModified( "Physical_Name", "Name" )
			Execute( "Drop Check_Constraint_Usage" )
			Execute( "Create Check_Constraint_Usage" )			
		]
	}
	@else
	{
		/* Cannot be here. */
		Pop
	}
]
SPItemEnd

SPItemBegin [keep format] = Alter Default
/* DESCRIPTION: Alter a default during alter script generation.   */
/* Assumes the context object is a default.                       */
[ ShouldGenerate
	ForEachReference( "Dependent_Objects_Ref" )
	{
		Execute( "Alter Default_Constraint_Usage" )
	}
]
SPItemEnd

SPItemBegin [keep format] = Alter Default_Constraint_Usage
/* DESCRIPTION: Alter default constraint usage during alter script generation.   */
/* Assumes the context object is a default constraint usage.                     */

[ ShouldGenerate

	/* Do not alter if the entire attribute was created. */
	PushOwner
	@ifnot ( IsCreated )
	{
		Pop

		/* The context is default constraint usage. */
		FE::Bucket( "94" ) "\n"        
		PushOwner PushOwner
		FE::RecordAlter
		"ALTER TABLE "  [ FE::OwnerOverride( "true" ) "." ] QuotedName  Pop "\n\t"   
		"MODIFY " QuotedName
		Pop
		[
			PushReference( "Default_Ref" )
			[ ShouldGenerate
				[
                    " DEFAULT "  FE::ExpandERwinMacro( "Server_Value" )
				]
			]
			Pop
		]
		FE::EndOfStatement
	}
	@else
	{
		/* The attribute was created. */
		Pop
	}
]
SPItemEnd

SPItemBegin [keep format] = Alter Entity
/* DESCRIPTION: Alter an entity during alter script generation. */
/* Assumes the context object is an entity.                     */
[ ShouldGenerate

	/* Entity name was changed, emit rename entity statement. */
	[ 
		[
			IsPropertyModified( "Name", "Physical_Name" )
			/* Make sure that the entity physical name was changed. */
			NotEqual( [ PushOldImage Property( "Physical_Name" ) Pop ], Property( "Physical_Name" ) )
			OnceForObject( "Alter Modify Object Physical Name" )
			FE::Bucket( "30" )
	
			/* RecordAlter allows us to suppress this statement later if the entity is dropped/recreated. */
			FE::RecordAlter
	
			"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] PushOldImage QuotedName Pop 
			" RENAME TO "  QuotedName
			FE::EndOfStatement
		]
		[
			/* Re-Create All existing dependent views so that their SQL */
	    		/* definitions refer to the parent entity using the new name */
			ForEachReference("Parent_Relationships_Ref")
			{
				PushReference("Child_Entity_Ref")
				[
					Equal(ObjectType,"View")
					@ifnot(IsCreated)
					{
						Execute("Generate View")
					}
				]
				Pop
			}
		]
	]

	/* Owner property. */
	[ IsPropertyModified( "Schema_Name" )
		OnceForObject( "Alter Modify Object Physical Name" )
		FE::Bucket("30") "\n"
		FE::RecordAlter
		"ALTER TABLE " [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" )
		" RENAME TO " [ FE::OwnerOverride( "true" ) "." ] QuotedName
		FE::EndOfStatement
	]

	/* Column order properties. */

	/* Check if the order of the old columns changed as alter may just insert     */
	/* new columns or remove columns without need for drop/recreate of the table. */

	[ IsPropertyModified( "Physical_Columns_Order_Ref" )
		FE::Option( "ColumnPhysicalOrder" )
		[ IsPropertyReordered( "Physical_Columns_Order_Ref", "existing_only" )
			Execute( "Generate Entity" )
		]
	]

	[ IsPropertyModified( "Columns_Order_Ref" )
		FE::Option( "!ColumnPhysicalOrder" )
		[ IsPropertyReordered( "Columns_Order_Ref", "existing_only" )
			Execute( "Generate Entity" )
		]
	]

	/* Comments. */
	[ IsPropertyModified( "Comment", "Definition" )
		IsPropertyNotEqual( "Data_Organization_Type", "913", "true" )
		FE::Option( "Comments" )
		FE::Bucket( "90" )
		FE::RecordAlter
		/* Truncate comment to 255 characters. */
		"COMMENT ON TABLE " [ FE::OwnerOverride ( "true" ) "." ] QuotedName
		" IS '" < Substitute( Left( Property( "Comment" ), "4000" ), "''", "'" ) > "'"
		FE::EndOfStatement
	]

	/* Was any property other than the name, comment, column order above modified? */
	[ FE::IsModified( "Name", "Physical_Name", "Schema_Name", "Physical_Columns_Order_Ref", 
					"Columns_Order_Ref", "Attributes_Order_Ref", "Comment", "Definition" )
		/* Drop/recreate the entity */
		Execute( "Generate Entity" )
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Generic Create Object
/* DESCRIPTION: Create an object during alter script generation.    */
/* The context can be any model object like entity, attribute etc.  */
[
	[ Execute( "Create " ObjectType )
		SetLocalFlag( "Template Found" )
	]

	@ifnot ( IsLocalFlagSet ( "Template Found" ) )
	{ 
		PushTopLevelObject
		@if ( IsCreated )
		{
			Execute( "Create " ObjectType )
		}
		@else
		{
			Execute( "Generate " ObjectType )
		}
		Pop
	}
	@else
	{
		ClearLocalFlag( "Template Found" )
	}
]
SPItemEnd

SPItemBegin [keep format] = Alter Generic Drop Object
/* DESCRIPTION: Drop an object during alter script generation.      */
/* The context can be any model object like entity, attribute etc.  */
[
	[ Execute( "Drop " ObjectType )
		SetLocalFlag( "Template Found" )
	]
	
	@ifnot ( IsLocalFlagSet( "Template Found" ) )
	{
		PushTopLevelObject
		@if ( IsDeleted )
		{
			Execute( "Drop " ObjectType )
		}
		@else
		{
			Execute( "Generate " ObjectType )
		}
		Pop
	}
	@else
	{
		ClearLocalFlag( "Template Found" )
	}
]
SPItemEnd

SPItemBegin [keep format] = Alter Generic Modify Object
/* DESCRIPTION: Modify an object during alter script generation.    */
/* The context can be any model object like entity, attribute etc.  */
[
	[ Execute( "Alter " ObjectType )
		SetLocalFlag( "Template Found" )
	]

	@ifnot ( IsLocalFlagSet( "Template Found" ) )
	{
		PushTopLevelObject
		[ Execute( "Generate " ObjectType ) ]
		Pop
	}
	@else 
	{
		ClearLocalFlag( "Template Found" )
	}
]
SPItemEnd

SPItemBegin [keep format] = Alter Key_Group
/* DESCRIPTION: Alter a key group during alter script generation. */
/* Assumes the context object is a key group.                     */
[ ShouldGenerate
	/* Key group name changed, emit rename statement. */
	[ IsPropertyModified( "Physical_Name", "Name" )
		[ NotEqual( [ PushOldImage Property( "Physical_Name" ) Pop ], Property( "Physical_Name" ) )
			OnceForObject( "Alter Modify Object Physical Name" )
			FE::Bucket( "30" )
			FE::RecordAlter
			"ALTER INDEX " [ FE::OwnerOverride( "true" ) "." ] PushOldImage QuotedName Pop
			" RENAME TO " QuotedName
			FE::EndOfStatement
		]
	]

	/* DB owner property changed */
	[ IsPropertyModified( "Schema_Name" )
		OnceForObject( "Alter Modify Object Physical Name" )
		FE::Bucket("30") "\n"
		FE::RecordAlter
		"ALTER INDEX " [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" )
		" RENAME TO " [ FE::OwnerOverride( "true" ) "." ] QuotedName
		FE::EndOfStatement
	]

	/* Was any property other than the name, constraint name, db owner, key group member order list modified? */
	[ FE::IsModified( "Physical_Name","Name","Constraint_Name","Schema_Name", "Key_Group_Members_Order_Ref" )
		/* Recreate the view. */
		Execute( "Generate Key_Group" )
	]
]

[ IsPropertyTrue( "Generate_As_Constraint" )
	/* Constraint name changed, emit rename statement. */
	[ IsPropertyModified( "Constraint_Name" )
		NotEqual( [ PushOldImage Property( "Constraint_Name" ) Pop ], Property( "Constraint_Name" ) )
		NotEqual( Left( Property( "Key_Group_Type" ), "2" ), "IF" ) /* this is handled in alter modify relationship */
		FE::Bucket( "30" ) "\n"
		PushOwner
		FE::RecordAlter
		"ALTER TABLE "
		[ FE::OwnerOverride( "true" ) "." ] QuotedName
		Pop
		" RENAME CONSTRAINT "  < PushOldImage Property("Constraint_Name") Pop  " TO " Property( "Constraint_Name" ) >
		FE::EndOfStatement
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Oracle_Constraint_State
/* DESCRIPTION: Alter Oracle constraint state during alter script generation.   */
/* Assumes the context object is a Oracle constraint state.                     */
[ PushOwner
	[ 
		@ifnot( IsModified )
		{
			PushOwner 
			[ 
				Equal( ObjectType, "Entity" ) Pop
				[ 
					Equal( ObjectType, "Check_Constraint_Usage" ) 
					[ Execute( "Generate Check_Constraint_Usage" ) ]
				]				
				[ 
					Equal( ObjectType, "Key_Group" ) 
					[ Execute( "Generate Key_Group" ) ]
				]
			]
			[ 
				Equal( ObjectType,"View" ) Pop				
				[ 
					Equal( ObjectType, "Key_Group" ) 
					[ Execute( "Generate Key_Group" ) ]
				]
			]
			[ Equal( ObjectType, "Attribute" ) Pop 
				[ Execute( "Generate Check_Constraint_Usage" ) ]
			]						      
		}		
	]
	Pop
]
SPItemEnd

SPItemBegin [keep format] = Alter Oracle_Database_Link
/* DESCRIPTION: Alter Oracle Database Link during alter script generation.   */
/* Assumes the context object is a Oracle Database Link.                     */
[
	Execute("Generate Oracle_Database_Link")
	ForEachReference( "Dependent_Objects_Ref" )
	{
		[ Equal( ObjectType, "Synonym" )
			Execute( "Generate Synonym" )
		]
	}
]
SPItemEnd

SPItemBegin [keep format] = Alter Relationship
/* DESCRIPTION: Alter a relationship during alter script generation. */
/* Assumes the context object is a relationship.                     */
[ ShouldGenerate

	[ IsPropertyModified( "Physical_Name", "Name" )
		NotEqual( [ PushOldImage Property( "Physical_Name" ) Pop ], Property( "Physical_Name" ) )
		OnceForObject( "Alter Modify Object Physical Name" )
		FE::Bucket( "30" ) "\n"
		/* set alter mark on the dependent FK key group */
		ForEachReference( "Dependent_Objects_Ref" )
		{
			[ Equal( ObjectType, "Key_Group" )
				Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )
				FE::RecordAlter
			]
		}
		PushReference( "Child_Entity_Ref" )
		"ALTER TABLE "
		[ FE::OwnerOverride( "true" ) "." ] Execute( "Previous Physical Name" )
		Pop
		" RENAME CONSTRAINT "  Execute( "Previous Physical Name" )  " TO " QuotedName
		FE::EndOfStatement
	]

	/* Recreate view if alias name was changed. */ 
	[ IsPropertyModified( "Alias_Name" )
		PushReference( "Child_Entity_Ref" )
		[ Equal( ObjectType, "View" )
			Execute( "Generate View" )
		]
		[ Equal( ObjectType, "Cached_View" )
			Execute( "Generate Cached_View" )
		]
		Pop
	]

	/* If any property other than the name or alias was changed, recreate FK constraints on dependent entities. */
	[ FE::IsModified( "Physical_Name", "Name", "Alias_Name" )
		ForEachReference( "Dependent_Objects_Ref" )
		{
			[ Equal( ObjectType, "Key_Group" )
				Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )
				[ 
					Execute ("Drop Constraint" )
					Execute( "Create Constraint" )                      
				]
			]
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Sequence
/* DESCRIPTION: Alter a sequence during alter script generation. */
/* Assumes the context object is a sequence.                     */
[ ShouldGenerate
	/* Sequence name changed, emit rename view statement. */
	[ IsPropertyModified( "Name" )
		NotEqual( [ PushOldImage Property( "Name" ) Pop ], Property( "Name" ) )
		@ifnot ( IsPropertyModified( "Schema_Name" ) )
		{
			OnceForObject( "Alter Modify Object Physical Name" )
			FE::Bucket( "30" )
			FE::RecordAlter
			"RENAME " PushOldImage QuotedName Pop
			" TO " QuotedName
			FE::EndOfStatement
		}
	]

	/* Was any property other than the name modified? */
	[ FE::IsModified( "Name" )
		/* Recreate the sequence. */
		Execute( "Generate Sequence" )
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Synonym
/* DESCRIPTION: Alter a synonym during alter script generation. */
/* Assumes the context object is a synonym.                     */
[ Execute( "Generate Synonym" ) ]
SPItemEnd

SPItemBegin [keep format] = Alter Trigger
/* DESCRIPTION: Alter a trigger during alter script generation. */
/* Assumes the context object is a trigger.                     */
[ ShouldGenerate
	/* View name changed, emit rename view statement. */
	[ IsPropertyModified( "Name" )
		@if ( DBMSVersion( "8" ) )
		{
			Execute( "Generate Trigger" )
		}
		@else
		{
			OnceForObject( "Alter Modify Object Physical Name" )
			NotEqual( [ PushOldImage Property( "Name" ) Pop ], Property( "Name" ) )
			FE::Bucket( "30" )
			FE::RecordAlter
			"ALTER TRIGGER " [ FE::OwnerOverride( "true" ) "." ] PushOldImage QuotedName Pop
			" RENAME TO " QuotedName
			FE::EndOfStatement
		}
	]

	/* Was any property other than the name modified? */
	[ FE::IsModified( "Name" )
		/* Recreate the trigger. */
		Execute( "Generate Trigger" )
	]
]
SPItemEnd

SPItemBegin [keep format] = Alter Validation_Rule
/* DESCRIPTION: Alter a validation rule during alter script generation.   */
/* Assumes the context object is a validation rule.                       */
[
	/* Alter dependent check constraint usages. */
	ForEachReference( "Dependent_Objects_Ref" )
	{
		[ Equal( ObjectType, "Check_Constraint_Usage" )
			Execute( "Generate Check_Constraint_Usage" )
		]
	}
]
SPItemEnd

SPItemBegin [keep format] = Alter View
/* DESCRIPTION: Alter a view during alter script generation. */
/* Assumes the context object is a view.                     */
[ ShouldGenerate
	/* View name changed, emit rename view statement. */
	[ IsPropertyModified( "Name" )
		NotEqual( [ PushOldImage Property( "Name" ) Pop ], Property( "Name" ) )
		@ifnot ( IsPropertyModified( "Schema_Name" ) )
		{
			FE::Bucket( "30" )
			FE::RecordAlter
			"RENAME " PushOldImage QuotedName Pop
			" TO " QuotedName
			FE::EndOfStatement
		}
	]

	/* Comments. */
	[ IsPropertyModified( "Definition" ) FE::Option( "Comments" )
		/* Generate the table-level comment.    */
		FE::Bucket( "90" )
		FE::RecordAlter
		"COMMENT ON TABLE "
		[ FE::OwnerOverride( "true" ) "." ] QuotedName
		" IS '" < Substitute( Left( Property( "Definition" ), "4000" ), "''", "'" ) >  "'"
		FE::EndOfStatement  
	]

	/* Was any property other than the name or comment modified? */
	[ FE::IsModified( "Name", "Definition" )
		/* Recreate the view. */
		Execute( "Generate View" )
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: AK Constraint
[
	Equal( Left( Property( "Key_Group_Type" ), "2" ), "AK" )
	IsPropertyTrue( "Generate_As_Constraint" )

	/* Generate it once. */
	OnceForObject( "Constraint" )

	/* Are we naming constraint? */
	[ FE::Option( "ConstraintName" )
		"CONSTRAINT  " [ FE::Option( "QuoteName" ) "\"" ] Property( "Constraint_Name" ) [ FE::Option( "QuoteName" ) "\"" ]
	]
	" UNIQUE "

	/* Index columns. */
	"("
	<
		ForEachReference( "Index_Members_Order_Ref" )
		{
			ListSeparator( "," )
			QuotedName
		}
	>
	")"

	/* Constraint state. */
	[ FE::Option( "ConstraintState" )
		ForEachOwnee( "Oracle_Constraint_State" )
		{
			Execute( "Clause: Constraint State" )
			[ FE::Option( "AKConstraintInAlter" )
				" EXCEPTIONS INTO "  
				PushReference( "Exception_Table_Ref" )
				[ FE::OwnerOverride( "true" ) "." ] QuotedName 
				Pop
			]
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Constraint State
/* Emit constraint state clause.                        */
/* Assumes that the context is Oracle Constraint State. */
[ "  " LookupProperty( "Is_Deferrable", "true", "DEFERRABLE", "false", "NOT DEFERRABLE" )  ]
[ "  INITIALLY " LookupProperty( "Is_Immediate", "true", "IMMEDIATE", "false", "DEFERRED" ) ]
[ "  " LookupProperty( "Consider_No_Validate", "true", "RELY", "false", "NORELY" ) ]
[
	/* Is owner a table key group? */
	PushOwner
	@if ( Equal( ObjectType, "Key_Group" ) )
	{
		PushOwner
		@if ( Equal( ObjectType, "Entity" ) )
		{
			SetLocalFlag( "Table Key Group Owner", "2" )
		}
		Pop
	}
	Pop 

	@if ( IsLocalFlagSet( "Table Key Group Owner" ) )
	{
		/* Is constraint in alter statement? */
		PushOwner
		Set( "Key_Group_Type", Left( Property( "Key_Group_Type" ), "2" ) )
		@if ( Equal( Value ( "Key_Group_Type" ), "PK" ) )
		{
			@if ( FE::Option( "PKConstraintInAlter" ) )
			{
				PushOwner
				[ NotEqual( ObjectType, "View" )
					@if ( IsPropertyEqual( "Oracle_Data_Storage_Type", "1" ) ) /* organization */
					{
						@if ( IsPropertyEqual( "Data_Organization_Type", "912" ) ) /* index */
						{
							SetLocalFlag( "Index Organized", "1" )
						}
					}
				]
				Pop
				
				@ifnot ( IsLocalFlagSet( "Index Organized" ) )
				{
					SetLocalFlag( "Constraint In Alter", "1" )  
				}
				@else
				{
					ClearLocalFlag( "Index Organized" )
				}
			}
		}
		@elseif( Equal( Value( "Key_Group_Type" ), "AK" ) )
		{
			@if ( FE::Option( "AKConstraintInAlter" ) )
			{
				SetLocalFlag( "Constraint In Alter", "1" )  
			}

		}
		@elseif( Equal( Value( "Key_Group_Type" ), "IF" ) )
		{
			@if ( FE::Option( "FKConstraintInAlter" ) )
			{
				SetLocalFlag( "Constraint In Alter", "1" )  
			}
		}
		Remove( "Key_Group_Type" )
		Pop

		@if ( IsLocalFlagSet( "Constraint In Alter" ) )
		{
			ClearLocalFlag( "Constraint In Alter" )
			
			IsPropertyEqual( "Use_Index", "908" ) "   USING INDEX "
			[ PushOwner
				[ IsGlobalFlagSet( "Create Key Group Body" ObjectId ) [ FE::OwnerOverride( "true" ) "." ] QuotedName ]
				SetGlobalFlag( "Create Key Group Body" ObjectId )
				[ Execute( "Clause: Index Properties" ) ]
				Pop
			]
		}
	}

	@if ( IsLocalFlagSet( "Table Key Group Owner" ) )
	{
		/*  Is this constraint in create statement? */
		PushOwner
		[ IsPropertyTrue( "Generate_As_Constraint" )
			Set( "Key_Group_Type", Left( Property( "Key_Group_Type" ), "2" ) )
			@if ( Equal( Value ( "Key_Group_Type" ), "PK" ) )
			{
				@if ( FE::Option( "PKConstraintInCreate" ) )
				{
					SetLocalFlag( "Constraint In Create", "1" )
				}
				@else
				{
					/* Is index organized? */
					PushOwner
					@if ( IsPropertyEqual( "Oracle_Data_Storage_Type", "1" ) ) /* organization */
					{
						@if ( IsPropertyEqual( "Data_Organization_Type", "912" ) ) /* index */
						{
							SetLocalFlag( "Constraint In Create", "2" )
						}
					}
					Pop
				}
			}
			@elseif( Equal( Value( "Key_Group_Type" ), "AK" ) )
			{
				@if ( FE::Option( "AKConstraintInCreate" ) )
				{
					SetLocalFlag( "Constraint In Create", "1" ) 
				}
	
			}
			@elseif( Equal( Value( "Key_Group_Type" ), "IF" ) )
			{
				@if ( FE::Option( "FKConstraintInCreate" ) )
				{
					SetLocalFlag( "Constraint In Create", "1" ) 
				}
			}
			Remove( "Key_Group_Type" )
		]
		Pop

		@if ( IsLocalFlagSet( "Constraint In Create" ) )
		{
			ClearLocalFlag( "Constraint In Create" )

			IsPropertyEqual( "Use_Index", "908" )     "  USING INDEX "         
			[
				[ PushOwner
					/* Constraint is not deferred; create an index if generated */
					[ ShouldGenerate "\n" "(" "\n" Execute( "Create Index" ) "\n" ") " ]
					Pop
				]
				[
					/* Constraint is deferred. */
					@if ( IsPropertyTrue( "Is_Deferrable" ) )
					{
						@if ( IsPropertyFalse( "Is_Immediate" ) )
						{
							SetLocalFlag( "Constraint Deferred" )
						}
					}
					@if ( IsLocalFlagSet( "Constraint Deferred" ) )
					{
						ClearLocalFlag( "Constraint Deferred" )
						PushOwner
						[
							/* create index */
							OnceForObject( "Create Key_Group" )
							FE::RecordCreate
							"CREATE" 
							[ "   " IsPropertyTrue( "Oracle_Bitmap" ) "BITMAP" ]
							" INDEX "
							[ FE::OwnerOverride( "true" ) "." ] QuotedName 
							" ON " [ FE::OwnerOverride( "true", "1" ) "." ] OwnerQuotedName
							"\n("
							<
								ForEachReference( "Index_Members_Order_Ref" )
								{
									ListSeparator( "," )
									@if ( IsPropertyNotNull( "Attribute_Ref" ) )
									{
										QuotedName
									}
									@else
									{
										Property( "Expression" )
									}
									[ "   " Property( "Key_Group_Sort_Order", "no_translate" ) ]
								}
							>
							")"

							/* TODO: do we need this flag? */
							SetGlobalFlag( "Create Key Group Body" ObjectId )
						]
						Pop
					}
				]
				[ PushOwner
					Execute( "Clause: Index Properties" )
					Pop
				]
			]
		}

	}
]
[ "  " LookupProperty( "Is_Enabled", "true", "ENABLE", "false", "DISABLE" ) ]
[ "  " LookupProperty( "Validate", "true", "VALIDATE", "false", "NOVALIDATE" ) ]
SPItemEnd

SPItemBegin [keep format] = Clause: Define Column
/* DESCRIPTION: Emit the column definition. */
/* Assumes the context object is a column.*/
"\t" Pad( QuotedName, 20 ) " "
@if ( IsPropertyNull ( "Character_Semantics_Type" ) )
{
	Property( "Physical_Data_Type" )
}
@else
{
	/* Remove closing braces. */
	Substitute( Property( "Physical_Data_Type" ), "", ")" ) " "
	LookupProperty( "Character_Semantics_Type", "907", "BYTE", "908", "CHAR" )
	/* Append closing braces if needed. */
	[ NotEqual( Property( "Physical_Data_Type" ), Substitute( Property( "Physical_Data_Type" ), "", ")" ) )  ")" ]
}

/* Timezone option. */
[ " " LookupProperty( "Time_Zone_Option", "904", "WITH TIME ZONE", "905", "WITH LOCAL TIME ZONE" ) ]

/* If generation of column defaults is turned on, emit it.  */
[ FE::Option( "ColumnDefaultValue" ) FE::Option( "ColumnDefaultInCreate" )
	[
		ForEachOwnee( "Default_Constraint_Usage" )
		{
			[ PushReference( "Default_Ref" )
                [ " DEFAULT  " FE::ExpandERwinMacro( "Server_Value" ) " " ]
				Pop
			]
		}
	]
]

@if ( IsPropertyTrue( "Oracle_Sort_Cluster_On_Column" ) ) 
{ 
	" SORT "
}
@else
{
	/* Null option. */
	[ FE::Option( "ConstraintName" )  
		" CONSTRAINT " [ FE::Option( "QuoteName" ) "\"" ] Property( "Null_Option_Constraint_Name" ) [ FE::Option( "QuoteName" ) "\"" ] ]
	[ " " EnumProperty( "Null_Option_Type", "NULL", "NOT NULL" ) " " ]

	/* Constraint state. */
	[ FE::Option( "ConstraintState" )
		[ PushReference( "Oracle_Constraint_State_Ref" ) 
			[ "\n\t\t\t" < Execute( "Clause: Constraint State" ) > ]
			Pop
		]
	]
}

/* If generation of column check constraints is on, emit it. */
[ FE::Option( "ColumnCheckConstraint" ) FE::Option( "ColumnConstraintInCreate" )
	ForEachOwnee( "Check_Constraint_Usage" )
	{
		ListSeparator( ",\n\t" )
		[ FE::Option( "ConstraintName" )
			" CONSTRAINT  " QuotedName
		]
		<
			PushReference( "Validation_Rule_Ref" )
			[ ShouldGenerate
                " CHECK (" FE::ExpandERwinMacro( "Server_Value" ) ")"
			]
			Pop
		>
		[ FE::Option( "ConstraintState" )
			[
				ForEachOwnee( "Oracle_Constraint_State" )
				{
					Execute( "Clause: Constraint State" )
				}
			]
		]
	}   
]
SPItemEnd

SPItemBegin [keep format] = Clause: FK Constraint
/* DESCRIPTION: Emit the FK constraint clause. */
/* Assumes the context object is a key group.  */
[
	Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )

	/* Check if the relationship is set to generate. */
	SetLocalFlag( "FK Should Generate" )
	PushReference( "Relationship_Ref" )
	@if ( ShouldGenerate )
	{
		PushReference( "Parent_Entity_Ref" )
		@ifnot ( FE::IsEntityInSubjectArea )
		{
			ClearLocalFlag( "FK Should Generate", "2" )
		}
		Pop
	}
	@else
	{
		ClearLocalFlag( "FK Should Generate", "1" )
	}
	Pop

	IsLocalFlagSet ( "FK Should Generate" )

	/* Generate it once            */
	OnceForObject( "Constraint" )
	
	/* Are we naming the contraints? */
	[ FE::Option( "ConstraintName" )

		/* Suppress default relationship names for subtypes. */
		[ PushReference( "Relationship_Ref" )
			[ Equal( Property( "Physical_Name" ), "is_a" )
				[ PushReference( "Parent_Entity_Ref" )
					[ Equal( ObjectType, "Subtype_Symbol" )
						SetLocalFlag( "Suppress Constraint Name", "2" )
					]
					Pop
				]
			]
			Pop
		]
		@ifnot( IsLocalFlagSet( "Suppress Constraint Name" ) )
		{
			"CONSTRAINT " QuotedNameThrough( "Relationship_Ref" ) " "
		}
		@else
		{
			ClearLocalFlag( "Suppress Constraint Name" )
		}
	]

	/* Emit the key group type. */
	"FOREIGN KEY "

	/* Emit the index members. */
	"("
	ForEachFKColumn
	{
		ListSeparator( ", " )
		QuotedName
	}
	")"

	/* Emit the referenced table.   */
	" REFERENCES "

	PushReference( "Relationship_Ref" )
	PushReference( "Parent_Entity_Ref" )
	Switch( ObjectType )
	{
		/* If the parent is an entity, just emit the name.  */
		Choose( "Entity" )
		{
			[ FE::OwnerOverride( "true" ) "." ] QuotedName " "
		}
		/* Subtypes, however, require a jump through the second relationship.   */
		Choose( "Subtype_Symbol" )
		{
			ForEachReference( "Child_Relationships_Ref" )
			{
				PushReference( "Parent_Entity_Ref" )
				[ FE::OwnerOverride( "true" ) "." ] QuotedName
				Pop
			}
		}
	}
	Pop
	Pop

	/* Emit the columns.    */
	"("
	ForEachMigratingColumn
	{
		ListSeparator( ", " )
		QuotedName
	}
	")"

	/* Emit declarative RI actions. */
	[ PushReference( "Relationship_Ref" )
		[ FE::Option( "OnDeleteFKConstraint" )
			" ON DELETE " 
			LookupProperty( "Parent_Delete_Rule", "10006", "SET NULL", "10005", "CASCADE" )
		]   
		Pop
	]

	/* Constraint State. */
	[ FE::Option( "ConstraintState" )
		ForEachOwnee( "Oracle_Constraint_State" )
		{
			Execute( "Clause: Constraint State" )
			[ FE::Option( "FKConstraintInAlter" )
				" EXCEPTIONS INTO "  
				PushReference( "Exception_Table_Ref" )
				[ FE::OwnerOverride( "true" ) "." ] QuotedName 
				Pop
			]
		}
	]

]
SPItemEnd

SPItemBegin [keep format] = Clause: Index Attributes
/* Assumes the context is Oracle Attribute Storage object. */
[ OnceForObject( "Index Attributes" )
	[ "\n\t" "PCTFREE " Property( "Oracle_Percent_Free" )  ]
	[ "\n\t" "INITRANS " Property( "Oracle_Initial_Transactions" ) ]
	[ "\n\t" "MAXTRANS " Property( "Oracle_Max_Transactions" ) ]
	[ "\n\t" "STORAGE ( " < Execute( "Clause: Storage" ) >  "\n\t )" ]
	[ "\n\t" LookupProperty( "Oracle_No_Logging", "true", "NOLOGGING", "false", "LOGGING" ) ]
	[ "\n\t" IsPropertyTrue( "Online" ) "ONLINE" ]
	[ "\n\t" IsPropertyTrue( "Use_Compute_Statistics" ) "COMPUTE STATISTICS" ]
	[ "\n\t" "TABLESPACE "  QuotedNameThrough( "Oracle_Tablespace_Ref" ) ]
	[ "\n\t" "TABLESPACE " IsPropertyEqual( "Oracle_Tablespace_Usage_Type", "0" ) "DEFAULT" ]
	[ "\n\t" LookupProperty( "Compress_Type", "919", "COMPRESS", "918", "NOCOMPRESS" ) " " [ Property( "Compress_Prefix_Length" ) ] ]
	[ "\n\t" LookupProperty( "Oracle_No_Sort", "true", "NOSORT" ,"false" ,"SORT" ) ]
	[ "\n\t" IsPropertyTrue( "Oracle_Use_Reverse_Store" ) "REVERSE" ]
	[ "\n\t" LookupProperty( "Parallel_Mode", "904", "PARALLEL", "905", "NOPARALLEL" ) [ " "  Property( "Oracle_Parallel_Threads" )  ] ]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Index Properties
/* Emit index physcial properties clause. */
/* Assumes the context is a key group.    */
[
	/* TODO: do we really need to check/set this flag? */
	IsGlobalFlagSet( "Create Key Group Body" ObjectId )
	SetGlobalFlag( "Create Key Group Body" ObjectId )

	[
		/* Check if the appropriate FE option is selected. */
		Set( "OwnerType", [ PushOwner ObjectType Pop ] )

		@if ( Equal( Value( "OwnerType" ), "Entity" ) )
		{
			@if ( FE::Option( "IndexPhysicalStorage" ) )
			{
				SetLocalFlag( "Storage Option" )        
			}           
		}
		@elseif( Equal( Value( "OwnerType" ), "Cached_View" ) )
		{
			@if ( FE::Option( "CreateCachedViewIndexPhysicalStorage" ) )
			{
				SetLocalFlag( "Storage Option" )        
			}
		}

		@if ( IsLocalFlagSet( "Storage Option" ) )
		{
			ForEachOwnee( "Oracle_Attribute_Storage" )
			{
				Execute( "Clause: Index Attributes" )
			}

			ClearLocalFlag( "Storage Option" )
		}
		Remove( "OwnerType" )
	]

	[
		/* Check index partition FE option. */
		
		Set( "OwnerType", [ PushOwner ObjectType Pop ] )

		@if ( Equal( Value( "OwnerType" ), "Entity" ) )
		{
			@if ( FE::Option( "IndexPartitions" ) )
			{
				SetLocalFlag( "Partition Option" )      
			}           
		}
		@elseif( Equal( Value( "OwnerType" ), "Cached_View" ) )
		{
			@if ( FE::Option( "CreateCachedViewIndexPartitions" ) )
			{
				SetLocalFlag( "Partition Option" )      
			}
		}
		
		Remove( "OwnerType" )

		@if ( IsLocalFlagSet( "Partition Option" ) )
		{
			OnceForObject( "Index Partition Option" )
			[ Equal( Property( "Oracle_Index_Partition_Type" ), "Global" )
				"\n\t" "GLOBAL "
				[
					ForEachOwnee( "Oracle_Index_Global_Partition" )
					{
						/* Range partitions */
						[ Equal( Property( "Oracle_Index_Global_Partition_Type" ), "Range" )
							" PARTITION BY RANGE "
							"("
							ForEachReference( "Columns_Ref" )
							{
								ListSeparator( "," )
								QuotedName
							}
							")"
	
							"\n\t" "("
							ForEachOwnee( "Oracle_Range_Partition_Info", "Object_Order" )
							{
								ListSeparator( ",\n\t" )
								"PARTITION " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ] " VALUES LESS THAN "
								"(" FormatProperty( "Partition_Values" ) ")"
								[
									ForEachOwnee( "Oracle_Partition_Description" )
									{
										Execute( "Clause: Partition Description" )
									}
								]
							}
							")"
						]
	
						/* Hash partitions */
						[ Equal( Property( "Oracle_Index_Global_Partition_Type" ), "Hash" )
							" PARTITION BY HASH " "("
							<
								ForEachReference( "Columns_Ref" )
								{
									ListSeparator( "," )
									QuotedName
								}
							>
							")"
							
							[ IsPropertyEqual( "Oracle_Index_Global_Hash_Partition_Type", "0" )
								"\n\t" "("
								ForEachOwnee( "Oracle_Individual_Hash_Partition", "Object_Order" ) 
								{
									ListSeparator( ",\n\t" )
									"PARTITION " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ]
									[
										ForEachOwnee( "Oracle_Partitioning_Storage" )
										{
											Execute( "Clause: Partitioning Storage" )   
										}
									]
								}
								")"
							]
						
							[ IsPropertyEqual( "Oracle_Index_Global_Hash_Partition_Type", "1" )
								"\n\t" "PARTITIONS " Property( "Oracle_Hash_Partition_Quantity" )
								[ 
									" STORE IN ("
									<
										ForEachReference( "Oracle_Tablespaces_Ref" )
										{
											ListSeparator( "," )
											QuotedName
										}
									>
									" ) "
								]
							]
						]
					}
				]
			]
	
			/* Local partitions. */
			[ Equal( Property( "Oracle_Index_Partition_Type" ), "Local" )
				"\n\t" " LOCAL "
				[
					ForEachOwnee( "Oracle_Index_Local_Partition" )
					{
						/* Range partitions. */
						[ Equal( Property( "Oracle_Partition_Type" ), "Range" )
							"\n\t" "("
							ForEachOwnee( "Oracle_Range_Partition_Info", "Object_Order" )
							{
								ListSeparator( "\n\t," )
								"PARTITION " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ]
								[
									ForEachOwnee( "Oracle_Partition_Description" )
									{
										Execute( "Clause: Partition Description" )
									}
								]
							}
							")"
						]
	
						/* List partitions. */
						[ Equal( Property( "Oracle_Partition_Type" ), "List" )
							"\n\t" "("
							ForEachOwnee( "Oracle_List_Partition_Info", "Object_Order" )
							{
								ListSeparator( "," )
								"\n\t"
								"PARTITION " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ]
								[
									ForEachOwnee( "Oracle_Partition_Description" )
									{
										Execute( "Clause: Partition Description" )
									}
								]
							}
							")"
						]
	
						/* Hash partitions. */
						[ Equal( Property( "Oracle_Partition_Type" ), "Hash" )
							[ Equal( Property( "Oracle_Hash_Partition_Type" ), "Individual" )
								"\n\t" "("
								ForEachOwnee( "Oracle_Individual_Hash_Partition", "Object_Order" )
								{
									ListSeparator( "," )
									"\n\t" 
									"PARTITION " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ]
									[
										ForEachOwnee( "Oracle_Partitioning_Storage" )
										{
											Execute( "Clause: Partitioning Storage" )
										}
									]
								}
								")"
							]
	
							[ Equal( Property( "Oracle_Hash_Partition_Type" ), "Quantity" )
								"\n\t" "STORE IN ("
								<
									ForEachReference( "Oracle_Tablespaces_Ref" )
									{
										ListSeparator( "," )
										QuotedName
									}
								>
								")"
							]
						]
	
						/* Composite Partitions */
						[ Equal( Property( "Oracle_Partition_Type" ), "Composite" )
							[ "\n\t" "STORE IN ("
								<
									ForEachReference( "Oracle_Tablespaces_Ref" )
									{
										ListSeparator( "," )
										QuotedName
									}
								>
								")"
							]
	
							[  "\n\t" "("
								ForEachOwnee( "Oracle_Range_Partition_Info", "Object_Order" )
								{
									ListSeparator( "," )
									"\n\t" 
									"PARTITION "  [ IsPropertyNull( "Is_Unnamed" ) QuotedName ]
									[
										ForEachOwnee( "Oracle_Partition_Description" )
										{
											Execute( "Clause: Partition Description" )
										}
									]
								}
								")"
							]
						]
					}
				]
			]
			ClearLocalFlag( "Partition Option" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: LOB Column Properties
/* Description: Emits column LOB Storage clause. */
/* Assumes that the context is an Cached view.   */
[
	@if ( FE::Option( "ColumnPhysicalOrder" ) )
	{
		Set( "Column Order", "Physical_Columns_Order_Ref" )
	}
	@else
	{
		Set( "Column Order", "Columns_Order_Ref" )
	}
	<
		ForEachReference( Value( "Column Order" ) )
		{
			"\n\t" "LOB " "(" QuotedName ")"
			<
				ForEachOwnee( "Oracle_LOB_Storage" )
				{
					[
						" STORE AS " [ IsPropertyNull( "Is_Unnamed" ) QuotedName " " ]
						ForEachOwnee( "Oracle_LOB_Parameters" )
						{
							[ " ( "  < Execute( "Clause: LOB Parameters" ) > ")" ]
						}
					]
				}
			>
		}
	>
]
SPItemEnd

SPItemBegin [keep format] = Clause: LOB Parameters
/* Emits Oracle LOB paramters clause.                          */
/* Assumes that the context object is an Oracle LOB parameter. */

[ "\n\t" "TABLESPACE " PushReference( "Oracle_Tablespace_Ref" ) QuotedName Pop ]
[ "\n\t" LookupProperty( "Enable_Storage_In_Row", "true", "ENABLE", "false", "DISABLE" ) " STORAGE IN ROW" ]
[ "\n\t" "STORAGE ( " < Execute( "Clause: Storage" ) > "\n\t )"  ]
[ "\n\t" "CHUNK " Property( "Oracle_Chunk" ) ]
[ "\n\t" "PCTVERSION " Property( "Oracle_LOB_Old_Version_Storage_Percent" ) ]
[ "\n\t" IsPropertyTrue( "Oracle_Is_Retaining_Version" ) "RETENTION" ]
[ "\n\t" "FREEPOOLS " Property( "Oracle_Freepools" ) ]
[ "\n\t" IsPropertyTrue( "Oracle_Cache" ) "CACHE" ]
[ "\n\t" LookupProperty( "Oracle_Cache", "false", "NOCACHE" ) " "   
	[ LookupProperty( "Oracle_No_Logging", "true", "NOLOGGING", "false", "LOGGING" ) ]
]
[ "\n\t" IsPropertyTrue( "Oracle_Cache_Read" ) "CACHE READS" " " 
	[ LookupProperty( "Oracle_No_Logging", "true", "NOLOGGING", "false", "LOGGING" ) ]
]
SPItemEnd

SPItemBegin [keep format] = Clause: PK Constraint
/* DESCRIPTION: Emit the PK constraint clause. */
/* Assumes the context object is a key group.  */
[ 
	Equal( Left( Property( "Key_Group_Type" ), "2" ), "PK" )
	IsPropertyTrue( "Generate_As_Constraint" )
	
	/* Generate it once. */
	OnceForObject( "Constraint" )

	/* Are we naming constraint? */
	[ FE::Option( "ConstraintName" )
		"CONSTRAINT  " [ FE::Option( "QuoteName" ) "\"" ] Property( "Constraint_Name" ) [ FE::Option( "QuoteName" ) "\"" ]
	]
	" PRIMARY KEY "
	"("
	<
		ForEachReference( "Index_Members_Order_Ref" )
		{
			ListSeparator( "," )
			QuotedName
		}
	>
	")"
	/* Constraint state */
	[ FE::Option( "ConstraintState" )
		[
			ForEachOwnee( "Oracle_Constraint_State" )
			{
				Execute( "Clause: Constraint State" )
			}
		]
		[ FE::Option( "PKConstraintInAlter" )
			/* Make sure that index is not organized. */
			PushOwner
			/* Views cannot be index organized. */
			@ifnot ( Equal( ObjectType, "View" ) )
			{
				Pop
				@if ( Equal ( OwnerProperty( "Oracle_Data_Storage_Type" ), "Organized" ) )
				{
					@if ( Equal( OwnerProperty( "Data_Organization_Type" ), "Index" ) )
					{
						SetLocalFlag( "Index Organized" )
					}
				}
			}
			@else
			{
				Pop
			}
			@ifnot ( IsLocalFlagSet( "Index Organized" ) )
			{
				ForEachOwnee( "Oracle_Constraint_State" )
				{
					[ " EXCEPTIONS INTO "  
						PushReference( "Exception_Table_Ref" )
						[ FE::OwnerOverride( "true" ) "." ] QuotedName 
						Pop
					]
				}
			}
			@else
			{
				ClearLocalFlag( "Index Organized" )
			}
		]
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Partition Description
/* Emit table partition description clause.                  */
/* Assumes that the context is Oracle Partition Description. */
[ PushReference( "Oracle_Regular_Storage_Ref" )  Execute( "Clause: Segment Attributes" ) Pop  ]
[ "\n\t" LookupProperty( "Compress_Type", "919", "COMPRESS", "918", "NOCOMPRESS" )" " 
	[ Property( "Compress_Prefix_Length" ) ]
]
[ "\n\t" IsPropertyTrue( "Use_Overflow" ) " OVERFLOW "
	[ PushReference( "Oracle_Overflow_Storage_Ref" ) Execute( "Clause: Segment Attributes" ) Pop ]
]

[
	ForEachOwnee( "Oracle_LOB_Storage" )
	{
		[
			/* LOB Storage */
			"\n\t" "LOB " "("
			<
				ForEachReference( "Columns_Ref" )
				{
					ListSeparator( "," )
					QuotedName
				}
			>
			")"
			/* LOB Storage Parameters */
			[
				" STORE AS " [ IsPropertyNull( "Is_Unnamed" ) QuotedName " " ]
				[
					ForEachOwnee( "Oracle_LOB_Parameters" )
					{
						[ " ( " < Execute( "Clause: LOB Parameters" ) > ")" ]
					}
				]
			]
		]
	}
]

[ NotEqual( [ Property( "Oracle_Partition_Level_Subpartition_Type" ) ], "Hash" ) 
	NotEqual( [ Property( "Oracle_Partition_Level_Subpartition_Type" ) ], "Spec" )
	/* If it is not hash quantity or sub partitions list, we have composite-list */

	/* Determine if sub-partitions have names  */
	ForEachOwnee( "Oracle_Subpartition_Spec", "Object_Order" )
	{
		IsPropertyNull( "Is_Unnamed" )
		SetLocalFlag( "Subpartitions Have Name", "1" )
	}

	@if ( IsLocalFlagSet( "Subpartitions Have Name" ) )
	{
		"\n\t" "("
	
		ForEachOwnee( "Oracle_Subpartition_Spec", "Object_Order" )
		{
			ListSeparator( ",\n\t" ) 
			[ "SUBPARTITION " IsPropertyNull( "Is_Unnamed" ) QuotedName "  " ]
			[ " VALUES ( " FormatProperty( "Partition_Values" ) " ) " ]
			[
				ForEachOwnee( "Oracle_Partitioning_Storage" ) 
				{
					Execute( "Clause: Partitioning Storage" )
				}
			]
		}
		")"

		ClearLocalFlag( "Subpartitions Have Name" )
	}
]

[ Equal( Property( "Oracle_Partition_Level_Subpartition_Type" ), "Hash" )
	["\n\t" "SUBPARTITIONS " Property( "Oracle_Hash_Partition_Quantity" ) ]
	[ 
		" STORE IN ("
		<
			ForEachReference( "Oracle_Tablespaces_Ref" )
			{
				ListSeparator( "," )
				QuotedName
			}
		>
		")"
	]
]

[ Equal( Property( "Oracle_Partition_Level_Subpartition_Type" ), "Spec" )
	"\n\t" "("
	ForEachOwnee( "Oracle_Subpartition_Spec", "Object_Order" )
	{
		ListSeparator( ",\n\t" ) 
		"SUBPARTITION " [ IsPropertyNull("Is_Unnamed" ) QuotedName "  " ]  [ " VALUES ( " FormatProperty( "Partition_Values" ) " ) "  ]
		[ 
			ForEachOwnee( "Oracle_Partitioning_Storage" )
			{
				Execute( "Clause: Partitioning Storage" )
			}
		]
	}
	")"
]
SPItemEnd

SPItemBegin [keep format] = Clause: Partitioning Storage
/* Emit table partitioning storage clause.                  */
/* Assumes that the context is Oracle Partitioning Storage  */
["\n\t" "TABLESPACE " PushReference( "Oracle_Tablespace_Ref" ) QuotedName Pop ]
["\n\t" IsPropertyTrue( "Use_Overflow" ) "OVERFLOW" "  " [ "TABLESPACE " PushReference( "Oracle_Overflow_Tablespace_Ref" ) QuotedName Pop ] ]
[
	ForEachOwnee( "Oracle_LOB_Storage" )
	{
		"\n\t" "LOB (" 
		<
			ForEachReference( "Columns_Ref" )
			{
				ListSeparator( "," )
				QuotedName
			}
		>
		")" 
		" STORE AS " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ] [" ( "  "TABLESPACE " PushReference( "Oracle_Tablespace_Ref" ) QuotedName Pop " ) " ]
	}
]
SPItemEnd

SPItemBegin [keep format] = Clause: Permanent Tablespace
/* Emit permanent tablespace clause.                      */
/* Assumes that the context is Oracle tablespace object.  */
["\n\t" "DATAFILE " "\n" 
	<
		ForEachOwnee( "Oracle_Physical_File", "Object_Order" )
		{
			ListSeparator( ",\n" )
			Execute( "Clause: Physical File Spec" )
		}
	>
]
[ "\n\t" "MINIMUM EXTENT " Property( "Minimum_Extent" )]
[ "\n\t" "BLOCKSIZE " Property( "Data_Block_Size" ) ]
[ "\n\t" LookupProperty( "Oracle_No_Logging", "true", "NOLOGGING", "false","LOGGING" ) ]
[ "\n\t" IsPropertyTrue( "Force_Logging" ) "FORCE LOGGING" ]
[ "\n\t" "DEFAULT " 
	<
		[ LookupProperty( "Compress_Type", "919", "COMPRESS", "918", "NOCOMPRESS" ) " " ]
		[ "STORAGE ( "
			<
				[ "\n\t\t" "INITIAL " Property( "Oracle_Initial_Extent_Size" ) ] 
				[ "\n\t\t" "NEXT " Property( "Oracle_Next_Extent_Size" ) ]
				[ "\n\t\t" "MINEXTENTS " Property( "Oracle_Min_Extents" ) ]
				[ "\n\t\t" "MAXEXTENTS " EnumProperty( "Oracle_Max_Extent_Type", "UNLIMITED", [ Property( "Oracle_Max_Extents" ) ] ) ]
				[ "\n\t\t" "PCTINCREASE " Property( "Oracle_Percent_Increase" ) ]
			>
			"\n\t )" 
		]
	>
]
[ "\n\t" LookupProperty( "Oracle_Is_Offline", "true", "OFFLINE", "false", "ONLINE" ) ]
[ IsPropertyEqual( "Extent_Management_Type", "922" )
	["\n\t" EnumProperty2( "Tablespace_Type", "1", " TEMPORARY", "PERMANENT" ) ]
]
[ "\n\t" "EXTENT MANAGEMENT " LookupProperty( "Extent_Management_Type", "922", "DICTIONARY", "923", "LOCAL" )
	[ "  " LookupProperty( "Local_Extent_Management_Type", "920", "AUTOALLOCATE", "921", "UNIFORM" )
		[" " "SIZE " Property( "Extent_Size" ) ]
	]
]
[ "\n\t" "SEGMENT SPACE MANAGEMENT " LookupProperty( "Segment_Management_Type", "927", "MANUAL", "926", "AUTO" ) ]
[ "\n\t" "FLASHBACK " LookupProperty( "Can_Flashback", "true", "ON", "false", "OFF" ) ]
SPItemEnd

SPItemBegin [keep format] = Clause: Physical Attributes
/* Emits physical attributes clause.                */
/* Assumes the current object is an Oracle storage. */

[ "\n\t" "PCTFREE " Property( "Oracle_Percent_Free" ) ]
[ "\n\t" "PCTUSED " Property( "Oracle_Percent_Used" ) ]
[ "\n\t" "INITRANS " Property( "Oracle_Initial_Transactions" ) ]
[ "\n\t" "MAXTRANS " Property( "Oracle_Max_Transactions" ) ]
[ "\n\t" "STORAGE ( " < Execute( "Clause: Storage" ) >  "\n\t )" ]
SPItemEnd

SPItemBegin [keep format] = Clause: Physical File Spec
/* Emits physical file specification clause.      */
/* Assumes the context is a Oracle physical file. */
[
	"\t" [ "'" IsPropertyNull( "Is_Unnamed" ) Property( "Name" ) "' " ] 
	[ "SIZE " Property( "Oracle_File_Size" ) ]
	[ "  " IsPropertyTrue( "Oracle_Can_Reuse_File" ) "REUSE" ]
	["  " "AUTOEXTEND " LookupProperty( "Auto_Extend", "true", "ON", "false", "OFF" ) 
		[" NEXT " Property( "Auto_Extend_Next_Value" ) ]
		[" MAXSIZE " LookupProperty( "Oracle_Max_Extent_Type", "0", "UNLIMITED" ) ]
		[" MAXSIZE " Property( "Auto_Extend_Max_Size" ) ] 
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Physical Properties
/* Emits physical properties clause.                      */
/* Assumes the context is an entity or materialized view. */

/* Regular tables. */
[ Equal( Property( "Oracle_Data_Storage_Type" ), "Regular" )
	[ PushReference( "Oracle_Regular_Storage_Ref" )
		Execute( "Clause: Segment Attributes" )
		Pop
	]
	[ "\n\t" LookupProperty( "Compress_Type", "919", "COMPRESS", "918", "NOCOMPRESS" ) " " ]
]

/* Organized tables. */
[ Equal( Property( "Oracle_Data_Storage_Type" ), "Organized" )
	/* Index organized tables. */
	[ Equal( Property( "Data_Organization_Type" ), "Index" )
		"\n\t"  "ORGANIZATION INDEX "
		[ PushReference( "Oracle_Index_Storage_Ref" ) Execute( "Clause: Segment Attributes" ) Pop ]
		[ "\n\t" LookupProperty( "Table_Mapping_Mode", "915", "MAPPING TABLE", "916", "NOMAPPING" ) ]
		[ "\n\t" "PCTTHRESHOLD " Property( "Percent_Threshold" ) ]
		[ "\n\t" LookupProperty( "Compress_Type", "919", "COMPRESS", "918", "NOCOMPRESS" ) " " [ Property( "Compress_Prefix_Length" ) ] ]
		[ "\n\t" IsPropertyTrue( "Use_Overflow" ) [ "INCLUDING " PushReference( "Including_Column_Ref" ) QuotedName Pop ]  " OVERFLOW "
			[ PushReference( "Oracle_Overflow_Storage_Ref" ) Execute( "Clause: Segment Attributes" ) Pop ] 
		]
	]
	/* External tables. */
	[  Equal( Property( "Data_Organization_Type" ), "External" )
		"\n\t"  "ORGANIZATION EXTERNAL "
		" ( "
		[ "\n\t\t" "TYPE " Property( "Access_Driver_Type" ) ]
		[ "\n\t\t" "DEFAULT DIRECTORY " PushReference( "Oracle_Directory_Ref" ) QuotedName Pop  ]
		[ NotEqual( Property( "Access_Parameter_Type" ), "Clob" ) "\n\t\t" "ACCESS PARAMETERS " "\n\t\t ( " Property( "Access_Parameters" ) "\n\t\t)" ]
		[ Equal( Property( "Access_Parameter_Type" ), "Clob" )  "\n\t\tACCESS PARAMETERS USING CLOB\n\t\t  " Property( "Access_Parameters" ) ]
		"\n\t\tLOCATION ("
		ForEachOwnee( "Oracle_Location" )
		{
			ListSeparator( ", " )
			[ PushReference( "Oracle_Directory_Ref" ) QuotedName Pop ":" ]
			"'" Property( "Name" ) "'"
		}
		")"
		"\n\t\t ) "
		["\n\t\t" "REJECT LIMIT " Property( "Reject_Limit" ) ]
		["\n\t\t" "REJECT LIMIT " LookupProperty( "Reject_Limit_Type", "0", "UNLIMITED" ) ]
	]
]

/* Cluster tables. */
[ Equal( Property( "Oracle_Data_Storage_Type" ), "Cluster" )
	"\n\t" "CLUSTER"  "  "     PushReference( "Oracle_Cluster_Ref" ) [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop " ("
	<
		ForEachReference( "Oracle_Cluster_Columns_Ref" )
		{
			ListSeparator( "," )
			QuotedName
		}
	>
	")"
] 
SPItemEnd

SPItemBegin [keep format] = Clause: Refresh Properties
/* Emit materialized view refresh properties clause. */
/* Assumes that the context is cached view.          */
[
	[ IsPropertyEqual( "Refresh_State", "911" ) 
		"\n\t" "NEVER REFRESH " 
	]
	[ IsPropertyEqual( "Refresh_State", "910" ) 
		"\n\t" "REFRESH " 
		<
			[ "\n\t\t" LookupProperty( "Refresh_Type", "912", "FAST", "913", "COMPLETE", "914", "FORCE" ) ]
			[ "\n\t\t" "ON " LookupProperty( "Refresh_Mode", "915", "DEMAND", "916", "COMMIT" ) ]
			[ "\n\t\t" "START WITH " Property( "Refresh_Start_Date" ) ]
			[ "\n\t\t" "NEXT " Property( "Refresh_Next_Date" ) ]
			[ "\n\t\t" "WITH " LookupProperty( "Refresh_With_Key_Type", "917", "PRIMARY KEY", "918", "ROWID" ) ]
			[ "\n\t\t" "USING "
				<
					Separator ("\n\t\t\t", 
						[
							/* State can be one of the following: Default = 902, Unspecified = 903, Specified = 919 */
							["\n\t\t\t" IsPropertyEqual( "Refresh_Local_Rollback_Segment_State", "902" ) "DEFAULT" " LOCAL ROLLBACK SEGMENT "  ]
							["\n\t\t\t" IsPropertyEqual( "Refresh_Local_Rollback_Segment_State", "919" ) " LOCAL ROLLBACK SEGMENT "   QuotedNameThrough( "Refresh_Local_Rollback_Segment_Ref" ) ]
							["\n\t\t\t" IsPropertyEqual( "Refresh_Master_Rollback_Segment_State", "902" ) "DEFAULT" " MASTER ROLLBACK SEGMENT " ]
							["\n\t\t\t" IsPropertyEqual( "Refresh_Master_Rollback_Segment_State", "919" ) " MASTER ROLLBACK SEGMENT " QuotedNameThrough( "Refresh_Master_Rollback_Segment_Ref" ) ]
						],
						[ LookupProperty ( "Oracle_Using_Constraint_Type", "0", "ENFORCED", "1", "TRUSTED" ) " CONSTRAINTS" ]
					)
				>
			]
		>
	]

	[ "\n\t" IsPropertyTrue( "Is_Updateable" ) "FOR UPDATE" ]
	[ "\n\t" LookupProperty( "Query_Rewrite_State_Mode", "921", "DISABLE", "920", "ENABLE") " QUERY REWRITE" ]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Segment Attributes
/* Emits the segment attributes clause.                       */
/* Assumes the context object is an Oracle physical storage.  */
[
	[ "\n\t" "TABLESPACE " PushReference( "Oracle_Tablespace_Ref" ) QuotedName Pop ]
	[ "\n\t" LookupProperty( "Oracle_No_Logging", "true", "NOLOGGING", "false", "LOGGING" ) ]
	[ Execute( "Clause: Physical Attributes" ) ]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Storage
/* Emits the segment attributes clause.                       */
/* Assumes the context object is an Oracle physical storage.  */

[ "\n\t\t" "INITIAL " Property( "Oracle_Initial_Extent_Size" ) ]
[ "\n\t\t" "NEXT " Property( "Oracle_Next_Extent_Size" ) ]
[ "\n\t\t" "MINEXTENTS " Property( "Oracle_Min_Extents" ) ]
[ "\n\t\t" "MAXEXTENTS " IsPropertyEqual( "Oracle_Max_Extent_Type", "0" ) "UNLIMITED" ]
[ "\n\t\t" "MAXEXTENTS " IsPropertyEqual( "Oracle_Max_Extent_Type",  "1" ) Property ( "Oracle_Max_Extents" ) ]
[ "\n\t\t" "PCTINCREASE " Property( "Oracle_Percent_Increase" ) ]
[ "\n\t\t" "FREELISTS " Property( "Oracle_Free_Lists" ) ]
[ "\n\t\t" "FREELIST GROUPS " Property( "Oracle_Free_List_Groups" ) ]
[ "\n\t\t" "BUFFER_POOL " LookupProperty( "Oracle_Buffer_Pool", "900", "KEEP", "901", "RECYCLE", "902", "DEFAULT" ) ]
SPItemEnd

SPItemBegin [keep format] = Clause: Subpartition Template
/* Emit table subpartition template clause.                  */
/* Assumes that the context is Oracle Composite Partition.   */
[ Equal( Property( "Oracle_Subpartition_Template_Type" ), "Individual" )
	"("
	ForEachOwnee( "Oracle_Partition_Template", "Object_Order" )
	{
		ListSeparator( "," )
		"\n\t" "SUBPARTITION " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ] [ " VALUES ("  < FormatProperty( "Partition_Values" ) >  ")" ]
		[
			ForEachOwnee( "Oracle_Partitioning_Storage" )
			{
				Execute( "Clause: Partitioning Storage" )
			}
		]
	}
	"\n\t"
	")"
]

[ Equal( Property( "Oracle_Subpartition_Template_Type" ), "Quantity" )
	[ " " Property( "Oracle_Hash_Partition_Quantity" ) ]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Supplemental Log
/* Emits the supplemental logging properties clause     */
/* Assumes the context object is an entity.             */
[
	Separator ( ",\n", 
		[
			/* Supplemental log group. */
			ForEachOwnee( "Oracle_Supplemental_Log_Group" )
			{
				ListSeparator( ",\n" )
				"SUPPLEMENTAL LOG GROUP " QuotedName
				"("
				ForEachOwnee( "Oracle_Supplemental_Log_Column" )
				{
					ListSeparator( "," )
					PushReference( "Column_Ref" ) [ QuotedName ] Pop
					[ IsPropertyTrue( "Has_No_Log" ) " NO LOG" ]
				}
				")"         
				[ IsPropertyTrue( "Log_Always" ) " ALWAYS" ]
			}
		],
		[   
			/* Supplemental id key. */
			"SUPPLEMENTAL LOG DATA ("
			<
				Separator( ",",
					[ IsPropertyTrue( "Oracle_Supplemental_Key_Log_All_Columns" ) "ALL" ],
					[ IsPropertyTrue( "Oracle_Supplemental_Key_Log_PK_Columns" ) "PRIMARY KEY" ],
					[ IsPropertyTrue( "Oracle_Supplemental_Key_Log_AK_Columns" ) "UNIQUE" ],
					[ IsPropertyTrue( "Oracle_Supplemental_Key_Log_FK_Columns" ) "FOREIGN KEY" ]
				)
			>
			") COLUMNS"
		]
	)
]
SPItemEnd

SPItemBegin [keep format] = Clause: Table Partition
/* Emit table partition clause.             */
/* Assumes the context object is an entity. */

/* Range Partitions */
[ Equal( Property( "Oracle_Partition_Type" ), "Range" )        
	[ 
		ForEachOwnee( "Oracle_Range_Partition" )
		{
			[ "\n\t" "PARTITION BY RANGE ("
				<
					ForEachReference( "Columns_Ref" )
					{
						ListSeparator( "," )
						QuotedName
					}
				>
				")"
				"\n\t" "(" 
				<
					ForEachOwnee( "Oracle_Range_Partition_Info", "Object_Order" )
					{
						ListSeparator( ",\n\t" )
						"PARTITION " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ] " VALUES LESS THAN "
						"(" FormatProperty( "Partition_Values" ) ")"
						[   
							ForEachOwnee( "Oracle_Partition_Description" )
							{
								Execute( "Clause: Partition Description" ) 
							}
						]
					}
				>
				")"
			]
		}
	]
]

/* List Partitions */
[ Equal( Property( "Oracle_Partition_Type" ), "List" )
	[
		ForEachOwnee( "Oracle_List_Partition" )
		{
			"\n\t" "PARTITION BY LIST ("
			QuotedNameThrough( "Column_Ref" )
			")"
			"\n\t" "("
			ForEachOwnee( "Oracle_List_Partition_Info", "Object_Order" )
			{
				ListSeparator( "," )
				"\n\t" 
				"PARTITION " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ] " VALUES "
				"(" FormatProperty( "Partition_Values" ) ")"
				[   
					ForEachOwnee( "Oracle_Partition_Description" )
					{
						Execute( "Clause: Partition Description" )
					}
				]
			}
			")"
		}
	]
]

/* Hash Partitions */   
[ Equal( Property( "Oracle_Partition_Type" ), "Hash" )
	[
		ForEachOwnee( "Oracle_Hash_Partition" )
		{
			[
				"\n\t" "PARTITION BY HASH ("
				<
					ForEachReference( "Columns_Ref" )
					{
						ListSeparator( "," )
						QuotedName
					}
				>
				")"
				[ Equal( Property( "Oracle_Hash_Partition_Type" ), "Individual" )
					"\n\t" "("
					ForEachOwnee( "Oracle_Individual_Hash_Partition", "Object_Order" )
					{
						ListSeparator( "," )
						"\n\t"
						"PARTITION " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ]
						[
							ForEachOwnee( "Oracle_Partitioning_Storage" )
							{
								Execute( "Clause: Partitioning Storage" )
							}
						]
					}
					")"
				]
				[ Equal( Property( "Oracle_Hash_Partition_Type" ), "Quantity" )
					[ "\n\t" "PARTITIONS " Property( "Oracle_Hash_Partition_Quantity" ) ]
					[ " STORE IN ("
						<
							ForEachReference( "Oracle_Tablespaces_Ref" )
							{
								ListSeparator( "," )
								QuotedName
							}
						>
						" ) "
					]
					[ " OVERFLOW STORE IN ("
						<
							ForEachReference( "Oracle_Overflow_Tablespaces_Ref" )
							{
								ListSeparator( "," )
								QuotedName
							}
						>
						" ) "
					]
				]
			]
		}
	]
]

/* Composite Partitions */
[ Equal( Property( "Oracle_Partition_Type" ), "Composite" )
	[ 
		ForEachOwnee( "Oracle_Composite_Partition" )
		{
			[ "\n\t" "PARTITION BY RANGE ("
				<
					ForEachReference( "Columns_Ref" )
					{
						ListSeparator( "," )
						QuotedName
					}
				>
				")"
				[ Equal( Property( "Oracle_Composite_Subpartition_Type" ), "List" )
					"\n\t" "SUBPARTITION  BY LIST (" QuotedNameThrough( "Column_Ref" ) ")"
					[ "\n\t" "SUBPARTITION TEMPLATE"  < Execute( "Clause: Subpartition Template" ) > ]
				]           
				[ Equal( Property( "Oracle_Composite_Subpartition_Type" ), "Hash" )
					"\n\t" "SUBPARTITION  BY HASH ("
					<
						ForEachReference( "Oracle_Hash_Columns_Ref" )
						{
							ListSeparator( "," )
							QuotedName
						}
					>
					")"
					[ Equal( Property( "Hash_Subpartition_Type" ), "Quantity" )
						"\r\n\t" "SUBPARTITIONS         " Property( "Oracle_Hash_Partition_Quantity" )
						[ " STORE IN ("
							<
								ForEachReference( "Oracle_Tablespaces_Ref" )
								{
									ListSeparator( "," )
									QuotedName
								}
							>
							")"
						]
					]

					[  Equal( Property( "Hash_Subpartition_Type" ), "Individual" )
						["\n\t" "SUBPARTITION TEMPLATE " < Execute( "Clause: Subpartition Template" ) > ]
					]
				]
				
				[ "\n\t("
					ForEachOwnee( "Oracle_Range_Partition_Info", "Object_Order" )
					{
						ListSeparator( "\n\t," )
						"PARTITION " [ IsPropertyNull( "Is_Unnamed" ) QuotedName ] " VALUES LESS THAN "
						"(" FormatProperty( "Partition_Values" ) ")"
						[ 
							ForEachOwnee( "Oracle_Partition_Description" )
							{
								Execute( "Clause: Partition Description" ) 
							}
						]
					}
					")"
				]
			]
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Table Properties
/* Emits table properties clause.            */
/* Assumes the current context is an entity. */
[
	/* Column LOB storage clause. */
	[ FE::Option( "ColumnLOBStorage" )
		IsPropertyFalse( "Oracle_Is_Temporary_Table" )		
		Execute( "Clause: LOB Column Properties" )
	]

	/* Table partitioning clause. */
	[ FE::Option( "TablePartitions" )
		Execute( "Clause: Table Partition" )
	]
	
	/* physical storage properties. */
	[ FE::Option( "TablePhysicalStorage" )
		["\n\t" LookupProperty( "Oracle_Cache", "true", "CACHE", "false", "NOCACHE" ) ]
		["\n\t" LookupProperty( "Parallel_Mode", "904", "PARALLEL", "905", "NOPARALLEL" ) [ " " Property( "Oracle_Parallel_Threads" ) ] ]
		["\n\t" LookupProperty( "Oracle_Has_Row_Dependencies", "true", "ROWDEPENDENCIES", "false", "NOROWDEPENDENCIES" ) ]
		["\n\t" LookupProperty( "Oracle_Enable_Row_Movement", "true", "ENABLE", "false", "DISABLE" ) "  ROW MOVEMENT" ]
		["\n\t" LookupProperty( "Is_Monitored", "true", "MONITORING", "false", "NOMONITORING" ) ]      
	]
]
SPItemEnd

SPItemBegin [keep format] = Clause: Temporary Tablespace
/* Emit temporary tablespace clause.                      */
/* Assumes that the context is Oracle tablespace object.  */
[ "\n\t" "TEMPFILE" "\n" 
	<
		ForEachOwnee( "Oracle_Physical_File", "Object_Order" )
		{
			ListSeparator( ",\n" )
			Execute( "Clause: Physical File Spec" )
		}
	>
]
[ "\n\t" "TABLESPACE GROUP " PushReference( "Tablespace_Group_Ref" ) QuotedName Pop ]
[ "\n\t" "BLOCKSIZE " Property( "Data_Block_Size" ) ]
[ "\n\t" IsPropertyTrue( "Force_Logging" ) "FORCE LOGGING" ]
[ "\n\t" "EXTENT MANAGEMENT " LookupProperty( "Extent_Management_Type", "922", "DICTIONARY", "923", "LOCAL" )
	[ "  " LookupProperty( "Local_Extent_Management_Type", "920", "AUTOALLOCATE", "921", "UNIFORM" ) 
		[ " " "SIZE " Property( "Extent_Size" ) ]
	]
]
[ "\n\t" "SEGMENT SPACE MANAGEMENT " LookupProperty( "Segment_Management_Type", "927", "MANUAL", "926", "AUTO" ) ]
[ "\n\t" "FLASHBACK " LookupProperty( "Can_Flashback", "true", "ON","false", "OFF" ) ]
SPItemEnd

SPItemBegin [keep format] = Clause: Undo Tablespace
/* Emit undo tablespace clause.                           */
/* Assumes that the context is Oracle tablespace object.  */
[ "\n\t" "DATAFILE" "\n" 
	<
		ForEachOwnee( "Oracle_Physical_File", "Object_Order" )
		{
			ListSeparator( ",\n" )
			Execute( "Clause: Physical File Spec" )
		}
	>
]
[ "\n\t" "EXTENT MANAGEMENT " LookupProperty( "Extent_Management_Type", "922", "DICTIONARY", "923", "LOCAL" )
	[ "  " LookupProperty( "Local_Extent_Management_Type", "920", "AUTOALLOCATE", "921", "UNIFORM" )
		[" " "SIZE " Property( "Extent_Size" ) ]
	]
]
[ "\n\t" "BLOCKSIZE " Property( "Data_Block_Size" )]
[ "\n\t" LookupProperty( "Oracle_Is_Offline", "true", "OFFLINE", "false", "ONLINE" ) ]
[ "\n\t" "FLASHBACK " LookupProperty( "Can_Flashback", "true", "ON","false","OFF")]
[ "\n\t" "RETENTION " LookupProperty("Retention_Guarantee", "true", "GUARANTEE", "false", "NOGUARANTEE" ) ]
SPItemEnd

SPItemBegin [keep format] = Clause: View FK Constraint
/* DESCRIPTION: Emit the view FK constraint clause. */
/* Assumes the context object is a key group.  */
[
	/* Check if FK view relationship is set to generate. */

	[ PushFKViewRelationship
		[ ShouldGenerate
			SetLocalFlag( "Should Generate", "1" )
		]
		Pop
	]

	IsLocalFlagSet ( "Should Generate" )
	Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )
	OnceForObject( "Constraint" )
	[
		"CONSTRAINT " FE::Option( "ConstraintName" ) 
		[ FE::Option( "QuoteName" ) "\"" ] Property( "Constraint_Name" ) [ FE::Option( "QuoteName" ) "\"" ] 
	]
	" FOREIGN KEY "
	"("
	<
		ForEachReference( "Index_Members_Order_Ref" )
		{
			ListSeparator( "," )
			QuotedName
		}
	>
	")"
	" REFERENCES "
	[
		<
			PushFKViewRelationship
			[
				PushReference( "Parent_Entity_Ref" )
					[FE::OwnerOverride( "true" ) "." ] QuotedName
				Pop
			]
			Pop
		>
	]
	[ FE::Option( "ConstraintState" )
		<
			ForEachOwnee( "Oracle_Constraint_State" ) 
			{
				Execute( "Clause: Constraint State" )
			}
		>
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Attribute
/* DESCRIPTION: Alter table to add an attribute during alter script generation. */
/* Assumes the context object is an attribute.                                  */
[
	PushOwner
	@if ( Equal ( ObjectType, "Entity" ) )
	{
		@ifnot ( IsCreated )
		{
			/* The entity was not created in this session. */

			Pop
			/* Current context is an attribute. */
		
			/* Determine if we can add column by altering table */
			@if ( FE::Option( "AlterStatements" ) )
			{
				/* User requested alter statement. */
				SetLocalFlag( "Use Alter To Add Column" )
			}
			@else
			{
				FE::IsLastColumn
				@ifnot ( IsPropertyEqual( "Null_Option_Type", "1" ) )
				{
					/* The column null option is NULL. */
					SetLocalFlag( "Use Alter To Add Column" )
				}
				@else
				{
					/* The column null option is NOT NULL, check if there is a default. */
					ForEachOwnee( "Default_Constraint_Usage" )
					{
						SetLocalFlag( "Use Alter To Add Column", "1" )
					}
				}
			}
			
			@if ( IsLocalFlagSet( "Use Alter To Add Column" ) ) 
			{
				FE::Bucket( "85" )
				PushOwner
				FE::RecordAlter
				"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop "\n\t"		
				"ADD (" QuotedName " "
				@if ( IsPropertyNull ( "Character_Semantics_Type" ) )
				{
					Property( "Physical_Data_Type" )
				}
				@else
				{
					/* Remove closing braces. */
					Substitute( Property( "Physical_Data_Type" ), "", ")" ) " "
					LookupProperty( "Character_Semantics_Type", "907", "BYTE", "908", "CHAR" )
					/* Append closing braces if needed. */
					[ NotEqual( Property( "Physical_Data_Type" ), Substitute( Property( "Physical_Data_Type" ), "", ")" ) )  ")" ]
				}
				[ LookupProperty( "Time_Zone_Option", "904", " WITH TIME ZONE", "905", " WITH LOCAL TIME ZONE" ) ]
				[ FE::Option( "ColumnDefaultValue" ) 
					ForEachOwnee( "Default_Constraint_Usage" ) 
					{
						[ PushReference( "Default_Ref" ) " "  
							@if ( IsPropertyNull( "Built_In_Id" ) )
							{
								" DEFAULT " 
							}
                            [ FE::ExpandERwinMacro( "Server_Value" ) ]
							Pop
						]
					}
				]
				[ " "  LookupProperty( "Null_Option_Type", "1", "NOT NULL" ) ]
				[ FE::Option( "ColumnCheckConstraint" ) 
					ForEachOwnee( "Check_Constraint_Usage" )
					{
						[ " " FE::Option( "ConstraintName" ) "CONSTRAINT "  QuotedName ]
						[ PushReference( "Validation_Rule_Ref" )
                            [ " CHECK ("  FE::ExpandERwinMacro( "Server_Value" ) ")" ] 
							Pop 
						] 
					}
				]
		
		
				")"
				FE::EndOfStatement

				/* Are we generating comments? */
				[ FE::Option( "Comments" )
					ShouldGenerate
					FE::Bucket( "90" )			
					IsOwnerPropertyNotEqual( "Data_Organization_Type", "913", "true" )
					"COMMENT ON COLUMN "
					[ FE::OwnerOverride( "true", "1" ) "." ]
					OwnerQuotedName "." QuotedName
					" IS '" < Substitute( Left( Property( "Comment" ), "4000" ), "''", "'" ) >  "'"
					FE::EndOfStatement						
				]
			}
			@else
			{
				/* We have to recreate the entity. */
				PushOwner
				[ Execute( "Generate Entity" ) ]
				Pop
			}
		}
		@else
		{
			Pop
		}	
	}
	@else
	{
		Pop
	}

]
SPItemEnd

SPItemBegin [keep format] = Create Cached_View
/* DESCRIPTION: Create a materialized view during schema generation.  */
/* Assumes the context object is a cached view.                       */
[ ShouldGenerate
	OnceForObject( "Create Cached_View" )
	FE::RecordCreate

	/* Is "CachedViewPreScript" option turned on? */
	[ FE::Option( "CachedViewPreScript" )
		ForEachReference( "Script_Templates_Ref" )
		{
			[ ShouldGenerate IsPropertyTrue( "Generate_As_Pre_Script" )
				FE::Bucket( "90" )
                FE::ExpandERwinMacro( "Template_Code" )
				FE::EndOfStatement( "true" )
			]
		}
	]

	[ FE::Option( "CreateCachedView" )
		FE::Bucket( "90" )
		@if ( IsPropertyNotNull( "User_Defined_SQL" ) )
		{
			Property( "User_Defined_SQL" )
		}
		@else
		{
			"CREATE MATERIALIZED VIEW " [ FE::OwnerOverride( "true" ) "." ] QuotedName
			@if ( IsPropertyTrue( "Oracle_Uses_Prebuilt_Table" ) )
			{
				"\n\t\t" "ON PREBUILT TABLE" ["  " LookupProperty( "Oracle_Uses_Reduced_Precision", "true", "WITH", "false", "WITHOUT" ) " REDUCED PRECISION" ]
			}
			@else
			{
				[ FE::Option( "CachedViewPhysicalStorage" ) Execute( "Clause: Physical Properties" ) ]
				[ FE::Option( "CachedViewLOBStorage" ) Execute( "Clause: LOB Column Properties" ) ]
				[ FE::Option( "CachedViewPartitions" ) Execute( "Clause: Table Partition" ) ]
				[  FE::Option( "CachedViewPhysicalStorage" )
					["\n\t" LookupProperty( "Oracle_Cache", "true", "CACHE", "false", "NOCACHE" ) ]
					["\n\t" LookupProperty( "Parallel_Mode", "904", "PARALLEL", "905", "NOPARALLEL" ) [ " " Property( "Oracle_Parallel_Threads" ) ] ]
					["\n\t" "BUILD " LookupProperty( "Index_Build_Type", "906", "IMMEDIATE", "907", "DEFERRED" ) ]
				]
			}
			[ FE::Option( "CachedViewUsingIndexStorage" )
				IsPropertyEqual( "Use_Index", "908" )
				"\n\t" "USING INDEX "
				[ PushReference( "Index_Ref" )
					[
						ForEachOwnee( "Oracle_Attribute_Storage" )
						{
							[ "\n\t" "TABLESPACE " QuotedNameThrough( "Oracle_Tablespace_Ref" ) ]
							[ "\n\t" "INITRANS " Property( "Oracle_Initial_Transactions" ) ]
							[ "\r\n\t" "MAXTRANS " Property( "Oracle_Max_Transactions" ) ]
							[ "\r\n\t" "PCTFREE " Property( "Oracle_Percent_Free" ) ]
							["\r\n\t" "STORAGE ( " < Execute( "Clause: Storage" ) >  "\n\t )" ]
						}
					]
					Pop
				]
			]
			[ FE::Option( "CachedViewUsingIndexStorage" )   
				IsPropertyEqual( "Use_Index", "909" )
				"\n\t" "USING NO INDEX "
			]

			[ FE::Option( "CachedViewPhysicalStorage" )
				Execute( "Clause: Refresh Properties" )
			]
			"\n\t" " AS "
			/* Select statement */
			
			" SELECT " 
			[ EnumProperty2( "Select_Type", "1", "ALL", "DISTINCT", "UNIQUE" ) " " ]    
			/* View columns. */
			<
				ForEachReference( "Physical_Columns_Order_Ref" )
				{
					ShouldGenerate
					ListSeparator( "," )
					[ PushReference( "Parent_Relationship_Ref" )
						@if ( IsPropertyNotNull( "Alias_Name" ) )
						{
							[ FE::Option( "QuoteName" ) "\"" ] Property( "Alias_Name" ) [ FE::Option( "QuoteName" ) "\"" ] "."
						}
						@else
						{
							PushReference( "Parent_Entity_Ref" )
							[ [ FE::OwnerOverride( "true" ) "."  ] 
								QuotedName "."
							]
							Pop
						}
						Pop
						
						PushReference( "Parent_Attribute_Ref" )
						[ PushOwner
							@if ( Equal( ObjectType, "Entity" ) )
							{
								/* Entity attribute. */
								Pop
								QuotedName
							}
							@else
							{
								/* View Attribute. */
								Pop
								QuotedName
							}
						]
						Pop
					]
					[ Property( "View_Expression" ) [ " AS " QuotedName ] ]
					[
						@if(IsPropertyNull("View_Expression"))
						{
							NotEqual( QuotedName, QuotedNameThrough( "Parent_Attribute_Ref" ) )
							PushOwner
							@if(Equal(ObjectType,"Cached_View")) 
							{
								Pop
								" AS " QuotedName
							}
						}
					]
				}
			>
			"\n\t\t" "FROM "
			/* From clause. */
			<
				ForEachReference( "Child_Relationships_Ref" )
				{
					ShouldGenerate
					ListSeparator( "," )
					[ PushReference( "Parent_Entity_Ref" )
						[ FE::OwnerOverride( "true" ) "." ] QuotedName
						Pop
					]
					[ " " Property( "Alias_Name" ) ]
				}
			>   
					
			[ "\n\t\t" "WHERE " Property( "Where_Clause" )]
			[ "\n\t\t" [ "START WITH " Property( "Start_With_Condition" ) " " ] "CONNECT BY " [ IsPropertyTrue( "No_Cycle" ) "NOCYCLE" " " ] Property( "Hierarchical_Condition" ) ]
			[ "\n\t\t" "GROUP BY " Property( "Group_By_Clause" ) ]
			[ "\n\t\t" "HAVING " Property( "Having_Clause" ) ]
			[ "\n\t\t" "ORDER BY " Property( "Order_By_Clause" ) ]

		}
		FE::EndOfStatement
	]

	/* Are we generating comments?  */
	[ FE::Option( "Comments" )
		FE::Bucket( "90" )

		OnceForObject( "Cached View Comment" )
		[ DBMSVersion( "8", "9" )
			"COMMENT ON TABLE "
			[ FE::OwnerOverride( "true" ) "."  ] QuotedName
			" IS '" < Substitute( Left( Property( "Definition" ), "4000" ), "''", "'" ) > "'"
			FE::EndOfStatement          
		]
		[ DBMSVersion( "10" )
			"COMMENT ON MATERIALIZED VIEW "
			[ FE::OwnerOverride( "true" ) "."  ] QuotedName
			" IS '" < Substitute( Left( Property( "Definition" ), "4000" ), "''", "'" ) >  "'"
			FE::EndOfStatement          
		]

		/* Generate the column-level comments.  */
		ForEachReference( "Physical_Columns_Order_Ref" )
		{
			[ "COMMENT ON COLUMN "
				[ FE::OwnerOverride( "true", "1" ) "." ] 
				OwnerQuotedName "." QuotedName
				" IS '" < Substitute( Left( Property( "Comment" ), "4000" ), "''", "'" ) > "'"
				FE::EndOfStatement
			]   
		}
	]


	/* Are we generating synonyms? */
	[ FE::Option( "CachedViewCreateSynonym" ) FE::Bucket( "90" )
		ForEachOwnee( "Synonym" )
		{
			ShouldGenerate
			Execute( "Create Synonym" )
		}
	]
	
	/* Stored procedures.   */
	[  
		ForEachReference( "Stored_Procedures_Ref" )
		{
			/* Make sure they should generate and that they are a table-level procedure.    */
			[ ShouldGenerate Equal( Property( "Type" ), "Table Level" )
				[ FE::Option( "CachedViewDropProcedureSynonym" )
					FE::Bucket( "100" ) 
					ForEachOwnee( "Synonym" )
					{
						ShouldGenerate
						Execute( "Drop Synonym" )
					}
				]
				[ FE::Option( "CachedViewDropProcedure" ) Execute( "Drop Stored_Procedure" ) ]
				[ FE::Option( "CachedViewCreateProcedure" ) Execute( "Create Stored_Procedure" ) ]
				[ FE::Option( "CachedViewCreateProcedureSynonym" )
					FE::Bucket( "100" ) 
					ForEachOwnee( "Synonym" )
					{
						ShouldGenerate
						Execute( "Create Synonym" )
					}
				]
			]
		}
	]

	/* Table-level functions.   */
	[
		ForEachReference( "Functions_Ref" )
		{
			/* Make sure they should generate and that they are a table-level function.    */
			[ ShouldGenerate Equal( Property( "Type" ), "Table Level" )
				[ FE::Option( "CachedViewDropFunctionSynonym" )
					FE::Bucket( "100" ) 
					ForEachOwnee( "Synonym" )
					{
						ShouldGenerate
						Execute( "Drop Synonym" )
					}
				]
				[ FE::Option( "CachedViewDropFunction" ) Execute( "Drop Function" ) ]
				[ FE::Option( "CachedViewCreateFunction" ) Execute( "Create Function" ) ]
				[ FE::Option( "CachedViewCreateFunctionSynonym" )
					FE::Bucket( "100" ) 
					ForEachOwnee( "Synonym" )
					{
						ShouldGenerate
						Execute( "Create Synonym" )
					}
				]
			]
		}
	]

	/* Triggers. */
	[ FE::Option( "CachedViewCreateTrigger" )
		ForEachOwnee( "Trigger" )
		{
			ShouldGenerate
			Execute( "Create Trigger" )
		}
	]

	/* View post script. */
	[ FE::Option("CachedViewPostScript") 
		ForEachReference( "Script_Templates_Ref" )
		{
			[ ShouldGenerate IsPropertyFalse( "Generate_As_Pre_Script" )
				FE::Bucket("90")
                FE::ExpandERwinMacro( "Template_Code" )
				FE::EndOfStatement( "true" )
			]
		}
	]

	[
		ForEachOwnee( "Key_Group" )
		{
			Execute( "Create Key_Group" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Check_Constraint_Usage
/* DESCRIPTION: Create a check constraint usage during alter script generation.   */
/* Assumes the context object is a check constraint usage.                        */
[
	OnceForObject("Create Check_Constraint_Usage")
	PushOwner
	@if ( Equal( ObjectType, "Attribute" ) )
	{
		/* Column-level check constraint. */
		@ifnot ( IsCreated )
		{
			/* Attribute was not created in this session. */
			Pop

			/* Current context is check constraint usage. */
			FE::Bucket( "11" ) "\n"			
			FE::RecordAlter
			PushOwner PushOwner
			"ALTER TABLE "  [ FE::OwnerOverride( "true" ) "." ] QuotedName  Pop "\n\t"   
			[ "MODIFY " QuotedName Pop " CONSTRAINT "  QuotedName  " " ]
			<
				PushReference( "Validation_Rule_Ref" )
					[ ShouldGenerate
						[
                            " CHECK ("  FE::ExpandERwinMacro( "Server_Value" ) ")"
						]
					]
				Pop
			>
			FE::EndOfStatement
		}
		@else
		{
			/* it's a new attribute. Check constraint is generated by the "create attribute" template. */
			Pop
		}
	}
	@else
	{
		/* Table-level check constraint. */
		@ifnot ( IsCreated )
		{
			/* Do not alter if the entire entity was created. */
			/* Current context is an entity. */
			FE::Bucket( "11" )
			FE::RecordAlter
			"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName
			Pop
			"\nADD ( "
			< [ FE::Option( "ConstraintName" ) " CONSTRAINT " QuotedName ]
				
				PushReference( "Validation_Rule_Ref" )
                [ " CHECK ( " FE::ExpandERwinMacro( "Server_Value" ) " ) " ]
				Pop
			>
			" ) "
			FE::EndOfStatement
		}
		@else
		{
			Pop
		}
	}
]
SPItemEnd

SPItemBegin [keep format] = Create Constraint
/* DESCRIPTION: Create a PK/FK/AK constraint.  */
/* Assumes the context object is a key group.  */
[
	FE::RecordCreate
	/* Build alter table constraint statement. */
	[ FE::Option( "PKConstraintInAlter" ) 
		Equal( Left( Property( "Key_Group_Type" ), "2" ), "PK" )
		[ FE::Bucket( "93" )
			PushOwner
			"ALTER " [ Equal( ObjectType, "Entity" ) "TABLE " ] [  Equal( ObjectType, "View" ) "VIEW " ] 
			[ FE::OwnerOverride( "true" ) "." ] QuotedName "\n"
			Pop
			"ADD " 	< Execute( "Clause: PK Constraint" ) >
			FE::EndOfStatement
		]
	]

	[ FE::Option( "AKConstraintInAlter" )
		Equal( Left( Property( "Key_Group_Type" ), "2" ), "AK" )			
		[ FE::Bucket( "93" )
			PushOwner
			"ALTER " [ Equal( ObjectType, "Entity" ) "TABLE " ] [ Equal( ObjectType, "View" ) "VIEW " ] 
			[ FE::OwnerOverride( "true" ) "." ] QuotedName "\n"
			Pop
			"ADD " 	< Execute( "Clause: AK Constraint" ) > 
			FE::EndOfStatement
		]
	]

	[ FE::Option( "FKConstraintInAlter")
		Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )
		[ FE::Bucket( "94" )
			PushOwner
			[ Equal( ObjectType, "Entity" )
				"ALTER "  "TABLE "  [ Equal( ObjectType, "View" ) "VIEW " ] 
				[ FE::OwnerQverride( "true" ) "." ] QuotedName "\n"
				Pop
				"ADD " 	< Execute( "Clause: FK Constraint" ) > 
				FE::EndOfStatement
			]
				
			[ Equal( ObjectType, "View" )
				"ALTER "  "VIEW " [ FE::OwnerQverride( "true" ) "." ] QuotedName 
				Pop
				"\n\t" "ADD " < Execute( "Clause: View FK Constraint" ) >
				FE::EndOfStatement
			]			
		]
	] 
]
SPItemEnd

SPItemBegin [keep format] = Create Default_Constraint_Usage
/* DESCRIPTION: Create a default constraint usage during alter script generation.   */
/* Assumes the context object is a default constraint usage.                        */
[
	Execute( "Alter Default_Constraint_Usage" )
]
SPItemEnd

SPItemBegin [keep format] = Create Entity
/* DESCRIPTION: Create an entity during schema generation.      */
/* Assumes the context object is an entity.                     */
[ ShouldGenerate
	/* Make sure that Create Entity is executed only once. */
	OnceForObject( "Create Entity" )
	
	/* Is the "TablePreScript" option turned on?    */
	[ FE::Option( "TablePreScript" )
		ForEachReference( "Script_Templates_Ref" )
		{
			[ ShouldGenerate IsPropertyTrue( "Generate_As_Pre_Script" )
				FE::Bucket( "90" )
                FE::ExpandERwinMacro( "Template_Code" )
				FE::EndOfStatement( "true" )
			]
		}
	]

	/* Is "CreateTable" option turned on? */
	[ FE::Option( "CreateTable" )
		/* Indicate to the internal post process that the entity has been created.       */
		/* This is used by the FE post process to suppress superceded alter statements.  */
		FE::RecordCreate

		FE::Bucket( "90" )

		"CREATE"

		[ IsPropertyTrue( "Oracle_Is_Temporary_Table" ) " GLOBAL TEMPORARY" ]

		" TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName

		"\n(\n"

		/* Columns.  We have to check sort order as some user don't bother  */
		/* with physical order and always generate using column order.  */
		@if ( FE::Option( "ColumnPhysicalOrder" ) )
		{
			Set( "Column Order", "Physical_Columns_Order_Ref" )
		}
		@else
		{
			Set( "Column Order", "Columns_Order_Ref" )
		}		
		<
			ForEachReference( Value( "Column Order" ) )
			{
				ListSeparator( ",\n" )
				Execute( "Clause: Define Column" )
			}
		>
		Remove( "Column Order" )

		/* Are we generating PK constraints in the CREATE? */
		[
			ForEachOwnee( "Key_Group" )
			{
				[ Equal( Left( Property( "Key_Group_Type" ), "2" ), "PK" )
					@if ( FE::Option( "PKConstraintInCreate" ) )
					{
						SetLocalFlag( "PKConstraintInCreate" )
					}
					@else
					{
						/* Check if index is organized. */
						@if ( Equal( OwnerProperty( "Oracle_Data_Storage_Type" ), "Organized" ) )
						{
							@if( Equal( OwnerProperty( "Data_Organization_Type" ), "Index" ) )
							{
								SetLocalFlag( "PKConstraintInCreate" )
							}
						}
					}

					IsLocalFlagSet( "PKConstraintInCreate" )
					ClearLocalFlag( "PKConstraintInCreate" )

					",\n" < Execute( "Clause: PK Constraint" ) >
				]
			}
		]

		/* Are we generating AK constraints in the CREATE? */
		[ FE::Option( "AKConstraintInCreate" )
			ForEachOwnee( "Key_Group" )
			{
				[ Equal( Left( Property( "Key_Group_Type" ), "2" ), "AK" )
					"," < Execute( "Clause: AK Constraint" ) >
				]
			}
		]
	
		/* Are we generating FKs in the CREATE? */
		[ FE::Option( "FKConstraintInCreate" )
			ForEachOwnee( "Key_Group" )
			{
				[ Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )
					/* Make sure the relationship is set to generate.   Also, make      */
					/* sure the parent table is not filtered out of the subject area.   */
					/* NB: This will need to be revisited if ERwin ever permits         */
					/* generation from a subject area other than the current one.       */
					SetLocalFlag( "Should Generate" )

					PushReference( "Relationship_Ref" ) 
					@if ( ShouldGenerate )
					{
						PushReference( "Parent_Entity_Ref" )
						@ifnot ( FE::IsEntityInSubjectArea )
						{
							ClearLocalFlag( "Should Generate", "2" )
						}

						Pop
					}
					@else
					{
						ClearLocalFlag( "Should Generate", "1" )
					}
					Pop
					
					@if ( IsLocalFlagSet( "Should Generate" ) )
					{
						",\n" < Execute( "Clause: FK Constraint" ) >
						ClearLocalFlag("Should Generate" )
					}
				]
			}
		]

		/* Table level check constraints in create.   */
		[ FE::Option( "TableCheckConstraint" ) FE::Option("TableConstraintInCreate")
			",\n"
			<
				ForEachOwnee( "Check_Constraint_Usage" )
				{
					ListSeparator( ",\n" )
					[ FE::Option( "ConstraintName" ) "CONSTRAINT " QuotedName " " ] 
					[
						[ PushReference( "Validation_Rule_Ref" )
							[ "CHECK " 
                                "( " FE::ExpandERwinMacro( "Server_Value" ) " )"
							]
							Pop
						]
						[ FE::Option( "ConstraintState" )
							ForEachOwnee( "Oracle_Constraint_State" )
							{
								Execute( "Clause: Constraint State" )
							}
						]
					]
				}
			>
		]

		/* Supplemental logging properties. */
		[ FE::Option( "TablePhysicalStorage" )
			",\n" < Execute( "Clause: Supplemental Log" ) >
		]

		"\n)" 

		
		[ "\n\t" "ON COMMIT " EnumProperty( "Oracle_Commit_Type", "DELETE", "PRESERVE" ) " ROWS" ]

		/* Physical properties. */
		[ FE::Option( "TablePhysicalStorage" )
			Execute( "Clause: Physical Properties" )
		]
		
		/* Table properties. */
		[ Execute( "Clause: Table Properties" ) ]

		FE::EndOfStatement
	]


	/* Are we generating comments?  */
	[ FE::Option( "Comments" )
		NotEqual( [ Property( "Data_Organization_Type" ) ], "External" )
		FE::Bucket( "90" ) 
		"COMMENT ON TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName " IS '"  
		/* truncate comment to 4000 characters */
		< Substitute( Left( Property( "Comment" ), "4000" ), "''", "'" ) >
		"'" 
		FE::EndOfStatement
	]

	/* Generate column-level comments.  */
	[ FE::Option( "Comments" )
		NotEqual( [ Property( "Data_Organization_Type" ) ], "External" )
		ForEachReference( "Physical_Columns_Order_Ref" )
		{
			[ IsPropertyNotNull( "Comment" )
				"COMMENT ON COLUMN "
				 [ FE::OwnerOverride( "true", "1" ) "." ]
				 OwnerQuotedName "." QuotedName
				" IS '" < Substitute( Left( Property( "Comment" ), "4000" ), "''", "'" ) > "'"
				FE::EndOfStatement
			]   
		}
	]

	/* Create table synonyms. */
	[ FE::Option( "TableCreateSynonym" )        
		FE::Bucket( "90" )
		ForEachOwnee( "Synonym" )
		{
			[ ShouldGenerate    
				Execute( "Create Synonym" )
			]
		}
	]

	/* Constraint State. */
	[ FE::Option( "ConstraintState" )
		ForEachOwnee( "Key_Group" )
		{
			[
				/* Is this index set to generate? */
				ShouldGenerate

				/* Make sure that the appropriate FE index option is selected. */
				Set( "Key_Group_Type", Left( Property( "Key_Group_Type" ), "2" ) )
				@if ( Equal( Value( "Key_Group_Type" ), "PK" ) )
				{
					FE::Option( "CreatePKIndex" )
					SetLocalFlag( "Should Generate" )
				}
				@elseif ( Equal( Value( "Key_Group_Type" ), "AK" ) )
				{
					FE::Option( "CreateAKIndex" )
					SetLocalFlag( "Should Generate" )
				}
				@elseif ( Equal( Value( "Key_Group_Type" ), "IF" ) )
				{
					FE::Option( "CreateFKIndex" )
					SetLocalFlag( "Should Generate" )
				}
				@elseif ( Equal( Value( "Key_Group_Type" ), "IE" ) )
				{
					FE::Option( "CreateIEIndex" )
					SetLocalFlag( "Should Generate" )
				}
				Remove( "Key_Group_Type" )

				@if ( IsLocalFlagSet( "Should Generate" ) )
				{
					ClearLocalFlag( "Should Generate" )
					ForEachOwnee( "Oracle_Constraint_State" ) /* there is only one. */
					{ 
						/* Generate if not deferred, avoiding 'Index not found' */
						IsPropertyFalse( "Is_Deferrable" )
						IsPropertyTrue( "Is_Immediate" )

						IsPropertyEqual( "Use_Index", "908" ) /* Use Default Index */

						/* Is ConstraintInAlter option selected? */
						/* This is a replacement of the "Using Index Specify Name" template. */

						PushOwner
						/* The context is a key group. */

						Set( "Key_Group_Type", Left( Property( "Key_Group_Type" ), "2" ) )
						@if ( Equal( Value( "Key_Group_Type" ), "PK" ) )
						{
							FE::Option( "PKConstraintInAlter" )
							/* Make sure it is NOT Index Organized. */
							PushOwner
							/* The context is an entity */
							@if( IsPropertyEqual( "Oracle_Data_Storage_Type", "1" ) ) /* organization */
							{
								@if ( IsPropertyEqual( "Data_Organization_Type", "912" ) )/* index */
								{
									SetLocalFlag( "Index Organized" )
								}
							}
							@ifnot ( IsLocalFlagSet( "Index Organized" ) )
							{
								SetLocalFlag( "Should Generate", "3" )
							}
							@else
							{
								ClearLocalFlag( "Index Organized" )
							}
							Pop
						}
						@elseif ( Equal( Value( "Key_Group_Type" ), "AK" ) )
						{
							FE::Option( "AKConstraintInAlter" )
							SetLocalFlag( "Should Generate", "2" )
						}
						@elseif ( Equal( Value( "Key_Group_Type" ), "IF" ) )
						{
							FE::Option( "FKConstraintInAlter" )
							SetLocalFlag( "Should Generate", "2" )  
						}
						Remove( "Key_Group_Type" )
						Pop
					}

					@if ( IsLocalFlagSet( "Should Generate" ) )
					{
						FE::Bucket( "90" )
						Execute( "Create Index" )
						FE::EndOfStatement
						ClearLocalFlag( "Should Generate" )
					}
				}
			]
		}
	]   

	/* Generate PK constraint and its corresponding index. */
	[
		ForEachOwnee( "Key_Group" )
		{
			Equal( Left( Property( "Key_Group_Type" ), "2" ), "PK" )
			[ FE::Bucket( "90" )
				Execute( "Create Key_Group" )
			]
			[ FE::Option( "PKConstraintInAlter" )
				/* Make sure it is NOT Index Organized. */
				PushOwner
				 /* The context is an entity */
				@if( IsPropertyEqual( "Oracle_Data_Storage_Type", "1" ) ) /* organization */
				{
					@if ( IsPropertyEqual( "Data_Organization_Type", "912" ) )/* index */
					{
						SetLocalFlag( "Index Organized", "1" )
					}
				}
				Pop
				/* The context is a key group. */
				@ifnot ( IsLocalFlagSet( "Index Organized" ) )
				{
					FE::Bucket( "90" )
					"ALTER TABLE " [ FE::OwnerOverride( "true", "1" ) "." ] OwnerQuotedName
					"\n\t" "ADD " < Execute( "Clause: PK Constraint" ) >
					[ FE::Option( "ConstraintState" )
						ForEachOwnee( "Oracle_Constraint_State" ) /* there is only one. */
						{
							[ IsPropertyEqual( "Use_Index", "908" )
								/* Generate index properties if deferred. */
								[ IsPropertyTrue( "Is_Deferrable" )
									PushOwner
									[ Execute( "Clause: Index Properties" ) ]
									Pop
								]

								[ IsPropertyFalse( "Is_Immediate" )
									PushOwner
									[ Execute( "Clause: Index Properties" ) ]
									Pop
								]
							]
						}
					]
					FE::EndOfStatement
				}
				@else
				{
					ClearLocalFlag( "Index Organized" )
				}
			]
		}
	]

	/* Generate Unique constraint and its corresponding Index. */
	/* Process indexes that are marked as constraints.         */
	[
		ForEachOwnee( "Key_Group", "Key_Group_Type" )
		{
			Equal( Left( Property( "Key_Group_Type" ), "2" ), "AK" )
			IsPropertyTrue( "Generate_As_Constraint" )
			[ FE::Bucket( "90" )
				Execute( "Create Key_Group" )   
			]
			[ FE::Option( "AKConstraintInAlter" )
				FE::Bucket( "90" )
				[ FE::Option( "CreateAKIndex" )
					ShouldGenerate
					< Execute( "Create Index" ) >
					FE::EndOfStatement "\n"
				]
				"ALTER TABLE " [ FE::OwnerOverride( "true", "1" ) "." ] OwnerQuotedName
				"\n" "ADD " < Execute( "Clause: AK Constraint" ) >
				[ FE::Option( "ConstraintState" )
					ForEachOwnee( "Oracle_Constraint_State" )
					{
						[ IsPropertyEqual( "Use_Index", "908" )
							[ IsPropertyTrue( "Is_Deferrable" )
								PushOwner
								[ Execute( "Clause: Index Properties" ) ]
								Pop
							]
							[ IsPropertyFalse( "Is_Immediate" )
								PushOwner
								[ Execute( "Clause: Index Properties" ) ]
								Pop
							]
						]
					}
				]
				FE::EndOfStatement
			]
		}
	]   

	/* Generate Unique constraint and its corresponding index. */
	/* Now process indexes that are NOT marked as constraints. */
	[ 
		ForEachOwnee( "Key_Group", "Key_Group_Type" )
		{
			Equal( Left( Property( "Key_Group_Type" ), "2" ), "AK" )
			IsPropertyFalse( "Generate_As_Constraint" )
			[ FE::Bucket( "90" )
				Execute( "Create Key_Group" )
			]
		}
	]

	/* Table check constraints in alter. */
	[ FE::Option( "TableCheckConstraint" )FE::Option( "TableConstraintInAlter" )
		ForEachOwnee( "Check_Constraint_Usage" )
		{
			PushOwner
			"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop "\n\t"
			"ADD " [ "CONSTRAINT  " FE::Option( "ConstraintName" ) QuotedName ]
			<
				[ PushReference( "Validation_Rule_Ref" )
                    [ " CHECK  (" FE::ExpandERwinMacro( "Server_Value" ) ")" ]
					Pop
				]
				[ FE::Option( "ConstraintState" )
					ForEachOwnee( "Oracle_Constraint_State" )
					{
						Execute( "Clause: Constraint State" )
					}
				]
			>
			FE::EndOfStatement
		}
	]

	/* Column check constraints in alter. */
	[ FE::Option( "ColumnCheckConstraint" ) FE::Option( "ColumnConstraintInAlter" )
		ForEachReference( "Physical_Columns_Order_Ref" )
		{
			ForEachOwnee( "Check_Constraint_Usage" )
			{
				PushOwner PushOwner
				"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop "\n\t"
				"MODIFY " QuotedName Pop
				<
					[ " CONSTRAINT  " FE::Option( "ConstraintName" ) QuotedName ]
					<
						PushReference( "Validation_Rule_Ref" )
						[ ShouldGenerate
                            " CHECK (" FE::ExpandERwinMacro( "Server_Value" ) ")"
						]
						Pop
					>
					[ FE::Option( "ConstraintState" )
						ForEachOwnee( "Oracle_Constraint_State" )
						{
							Execute( "Clause: Constraint State" )
						}
					]
				>
				FE::EndOfStatement
			}
		}       
	]

	/* Column defaults in alter. */
	[ FE::Option( "ColumnDefaultValue" ) FE::Option( "ColumnDefaultInAlter" )		
		ForEachReference( "Physical_Columns_Order_Ref" )
		{
			ForEachOwnee( "Default_Constraint_Usage" )
			{
				PushOwner PushOwner
				"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop "\n\t"
				"MODIFY " QuotedName Pop
				<
					PushReference( "Default_Ref" )
                    [ " DEFAULT " FE::ExpandERwinMacro( "Server_Value" ) ]
					Pop
				>
				FE::EndOfStatement
			}
		}
	]

	/* Generate non-unique indexes (IE and IF) */
	[
		ForEachOwnee( "Key_Group", "Key_Group_Type" )
		{
			[
				NotEqual( Left( Property( "Key_Group_Type" ), "2" ), "PK" )
				NotEqual( Left( Property( "Key_Group_Type" ), "2" ), "AK" )
				[ FE::Bucket( "90" )
					Execute( "Create Key_Group" )
				]
			]
		}
	]

	/* Oracle Cached View Log. */
	[
		ForEachOwnee( "Oracle_Cached_View_Log" )
		{
			ShouldGenerate
			Execute( "Create Oracle_Cached_View_Log" ) 
		}
	]

	/* FK constraint in alter. */
	[ FE::Option( "FKConstraintInAlter" )
		ForEachOwnee( "Key_Group" )
		{
			[ FE::Bucket( "94" )
				"ALTER TABLE " PushOwner [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop
				"\n\t" "ADD " "(" < Execute( "Clause: FK Constraint" ) > ")"
				[ FE::Option( "ConstraintState" )
					ForEachOwnee( "Oracle_Constraint_State" )
					{
						IsPropertyEqual( "Use_Index", "908" )
						[ IsPropertyTrue( "Is_Deferrable" )
							PushOwner
							[ Execute( "Clause: Index Properties" ) ]
							Pop
						]
						[ IsPropertyFalse( "Is_Immediate" )
							PushOwner
							[ Execute( "Clause: Index Properties" ) ]
							Pop
						]
					}
				]
				FE::EndOfStatement
			]
		}   
	]


	[ FE::Option( "ConstraintState" ) FE::Option( "ConstraintName" )
		ForEachOwnee( "Key_Group" )
		{
			[
				/* Is this constraint in create statement? */
				IsPropertyTrue( "Generate_As_Constraint" )

				Set( "Key_Group_Type", Left( Property( "Key_Group_Type" ), "2" ) )
				@if ( Equal( Value( "Key_Group_Type" ), "PK" ) )
				{
					@if ( FE::Option( "PKConstraintInCreate" ) )
					{
						SetLocalFlag( "Should Generate" )
					}
					@else
					{
						/* Is index organized? */
						PushOwner
						@if ( IsPropertyEqual( "Oracle_Data_Storage_Type", "1" ) ) /* organization */
						{
							@if ( IsPropertyEqual( "Data_Organization_Type", "912" ) ) /* index */
							{
								SetLocalFlag( "Should Generate", "1" )
							}
						}
						Pop
					}
				}
				@elseif ( Equal( Value( "Key_Group_Type" ), "AK" ) )
				{
					FE::Option( "AKConstraintInCreate" )
					SetLocalFlag( "Should Generate" )
				}
				@elseif ( Equal( Value( "Key_Group_Type" ), "IF" ) )
				{
					FE::Option( "FKConstraintInCreate" )
					SetLocalFlag( "Should Generate" )
				}

				Remove( "Key_Group_Type" )              

				@if ( IsLocalFlagSet( "Should Generate" ) )
				{
					[
						ForEachOwnee( "Oracle_Constraint_State" )
						{
							PushOwner PushOwner
							"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName
							Pop
							" ENABLE " [ "CONSTRAINT  " [ FE::Option( "QuoteName" ) "\"" ] Property( "Constraint_Name" ) [ FE::Option( "QuoteName" ) "\"" ]  ]
							Pop
							" EXCEPTIONS INTO " PushReference( "Exception_Table_Ref" ) [FE::OwnerOverride( "true" ) "." ] QuotedName Pop
							FE::EndOfStatement
						}
					]
					ClearLocalFlag( "Should Generate" )
				}
			]
		}
	]


	[ FE::Option( "ColumnCheckConstraint" ) FE::Option( "ConstraintState" ) FE::Option( "ConstraintName" )
		FE::Bucket( "90" )
		ForEachReference( "Physical_Columns_Order_Ref" )
		{
			PushOwner
			"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName
			Pop
			" ENABLE " [ "CONSTRAINT " [ FE::Option( "QuoteName" ) "\"" ] Property( "Null_Option_Constraint_Name" ) [ FE::Option( "QuoteName" ) "\"" ] ]
			<
				ForEachOwnee( "Oracle_Constraint_State" )
				{
					" EXCEPTIONS INTO " PushReference( "Exception_Table_Ref" ) [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop
				}
			>
			FE::EndOfStatement
		}
	
		ForEachReference( "Physical_Columns_Order_Ref" )
		{
			ForEachOwnee( "Check_Constraint_Usage" )
			{
				FE::Bucket( "90" )
				PushOwner
				PushOwner
				"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName
				Pop
				Pop
				" ENABLE " [ "CONSTRAINT " QuotedName ]
				<
					ForEachOwnee( "Oracle_Constraint_State" )
					{
						" EXCEPTIONS INTO " PushReference( "Exception_Table_Ref" ) [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop                   
					}
				>
				FE::EndOfStatement
			}
		}
	]

	[ FE::Option( "TableCheckConstraint" ) FE::Option( "ConstraintState") FE::Option( "ConstraintName" )
		ForEachOwnee( "Check_Constraint_Usage" )
		{
			FE::Bucket( "90" )
			PushOwner
			"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName
			Pop

			" ENABLE " [ "CONSTRAINT " QuotedName ]
			<
				ForEachOwnee( "Oracle_Constraint_State" )
				{
					" EXCEPTIONS INTO " PushReference( "Exception_Table_Ref" ) [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop
				}
			>
			FE::EndOfStatement
		}
	]

	/* Table level stored procedures. */
	[
		ForEachReference( "Stored_Procedures_Ref" )
		{
			ShouldGenerate
			Equal( Property( "Type" ), "Table Level" )
			
			[ FE::Option( "TableDropProcedure" ) Execute( "Drop Stored_Procedure" ) ]
			[ FE::Option( "TableCreateProcedure" ) Execute( "Create Stored_Procedure" ) ]

		}
	]

	/* Table level functions. */
	[
		ForEachReference( "Functions_Ref" )
		{
			ShouldGenerate
			Equal( Property( "Type" ), "Table Level" )
			[ FE::Option( "TableDropFunction" ) Execute( "Drop Function" ) ]
			[ FE::Option( "TableCreateFunction" ) Execute( "Create Function" ) ]
		}
	]

	/* Is the "TablePostScript" option turned on?    */
	[ FE::Option( "TablePostScript" )
		ForEachReference( "Script_Templates_Ref" )
		{
			[ ShouldGenerate IsPropertyFalse( "Generate_As_Pre_Script" )
				FE::Bucket( "90" )
                FE::ExpandERwinMacro( "Template_Code" )
				FE::EndOfStatement( "true" )
			]
		}
	]
	
	/*  User Defined Trigger for Entity */
	[ 
		FE::Option( "GenerateUserDefinedTrigger" )	
		ForEachOwnee( "Trigger" )
		{
			ShouldGenerate
			Execute( "Create Trigger" )
		}
	]
	
	/* Erwin generated triggers. */
	[
		FE::Option( "ERwinGeneratedTrigger" )
		FE::Bucket( "110" )
		FE::EmitERwinGeneratedTriggers
	]

]
SPItemEnd

SPItemBegin [keep format] = Create Function
/* DESCRIPTION: Create a function  during schema generation.      */
/* Assumes the context object is a function.					  */
[ ShouldGenerate
	OnceForObject( [ Repush( "1" ) ObjectId Pop ] "Create Function" )

	FE::RecordCreate
	FE::Bucket( "105" )
	@if(Equal( Property( "Type" ), "Table Level" ))
	{
		@if( IsPropertyTrue( "Generate_As_Pre_Script" ) )
		{
			FE::Bucket( "57" )
		}
		@else
		{
			FE::Bucket( "105" )
		}
	}
    FE::ExpandERwinMacro( "Template_Code" )
	"\n\/\n\n"
	FE::EndOfStatement( "true" )
	[ 
		FE::Option( "TableCreateFunctionSynonym" )
		FE::Bucket( "105" )
		ForEachOwnee( "Synonym" )
		{
			ShouldGenerate
			Execute( "Create Synonym" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Index
/* DESCRIPTION: Create an index during schema generation.         */
/* Assumes the context object is a key group.                     */
/* TODO: replacement for the old "Create Key Group Raw"           */
[ OnceForObject( "Create Key_Group" )
	FE::RecordCreate
	/* Suppress duplicate indexes. */
	SetLocalFlag( "Should Generate" )
	Set( "Key Group Members", Execute( "Key Group Members" ) )
	PushOwner
	@if ( IsGlobalFlagSet( "IndexCreated" Value( "Key Group Members" ) ObjectId ) )
	{
		/* Duplicate index, don't generate it. */
		ClearLocalFlag( "Should Generate", "1" )
	}
	@else
	{
		SetGlobalFlag( "IndexCreated" Value( "Key Group Members" ) ObjectId )
	}
	Pop
	Remove( "Key Group Members" )
	@if ( IsLocalFlagSet( "Should Generate" ) )
	{
		"CREATE" 
		
		[ " " 
			/* Is constraint deferred? */
			ForEachOwnee( "Oracle_Constraint_State" )
			{
				@if ( IsPropertyTrue( "Is_Deferrable" ) )
				{
					@if ( IsPropertyFalse ( "Is_Immediate" ) )
					{
						SetLocalFlag( "Constraint Deferred", "1" )
					}
				}
			}
			@ifnot ( IsLocalFlagSet( "Constraint Deferred" ) )
			{
				IsPropertyTrue( "Is_Unique" ) "UNIQUE"              
			}
			@else
			{
				ClearLocalFlag( "Constraint Deferred" )
			}
		]
		[ "   " IsPropertyTrue( "Oracle_Bitmap" ) "BITMAP" ]
		" INDEX "
		[ FE::OwnerOverride( "true" ) "." ] QuotedName 
		" ON " [ FE::OwnerOverride( "true", "1" ) "." ] OwnerQuotedName
		"\n("
		<
			ForEachReference( "Index_Members_Order_Ref" )
			{
				ListSeparator( "," )
				@if ( IsPropertyNotNull( "Attribute_Ref" ) )
				{
					QuotedName
				}
				@else
				{
					Property( "Expression" )
				}
				[ "   " Property( "Key_Group_Sort_Order", "no_translate" ) ]
			}
		>
		")"

		/* TODO: do we need this flag? */
		SetGlobalFlag( "Create Key Group Body" ObjectId )

		Execute( "Clause: Index Properties" )
		ClearLocalFlag( "Should Generate" )
	}

]
SPItemEnd

SPItemBegin [keep format] = Create Key_Group
/* DESCRIPTION: Create an index during schema generation.         */
/* Assumes the context object is a key group.                     */
[
 
	[ FE::IsAlterScriptGeneration
		PushOwner
		@if ( Equal( ObjectType, "Entity" ) )
		{
			SetLocalFlag( "Generate Constraint", "1" )
		}
		@elseif ( Equal( ObjectType, "View" ) )
		{
			SetLocalFlag( "Generate Constraint", "1" )
		}
		Pop
		@if ( IsLocalFlagSet( "Generate Constraint" ) )
		{
			Execute( "Create Constraint" )
			ClearLocalFlag( "Generate Constraint" )
		}
	]

	[ ShouldGenerate
		/* Make sure that the appropriate FE index option is selected. */
		/* TODO: replacement for Index Create Option                   */
		PushOwner
		@if ( Equal( ObjectType, "Entity" ) )
		{
			Pop
			Set( "Key_Group_Type", Left( Property( "Key_Group_Type" ), "2" ) )
			@if ( Equal( Value( "Key_Group_Type" ), "PK" ) )
			{
				FE::Option( "CreatePKIndex" )
				SetLocalFlag( "Should Generate" )
			}
			@elseif ( Equal( Value( "Key_Group_Type" ), "AK" ) )
			{
				FE::Option( "CreateAKIndex" )
				SetLocalFlag( "Should Generate" )
			}
			@elseif ( Equal( Value( "Key_Group_Type" ), "IF" ) )
			{
				FE::Option( "CreateFKIndex" )
				SetLocalFlag( "Should Generate" )
			 }
			 @elseif ( Equal( Value( "Key_Group_Type" ), "IE" ) )
			 {
				 FE::Option( "CreateIEIndex" )
				 SetLocalFlag( "Should Generate" )
			 }
			 Remove( "Key_Group_Type" )
		}
		@elseif ( Equal ( ObjectType, "Cached_View" ) )
		{
			Pop
			Set( "Key_Group_Type", Left( Property( "Key_Group_Type" ), "2" ) )
			@if ( Equal( Value( "Key_Group_Type" ), "AK" ) )
			{
				FE::Option( "CreateCachedViewAlternateKeyIndex" )
				SetLocalFlag( "Should Generate" )
			}
			@elseif ( Equal( Value( "Key_Group_Type" ), "IE" ) )
			{
				FE::Option( "CreateCachedViewInversionEntryIndex" )
				SetLocalFlag( "Should Generate" )
			}
			Remove( "Key_Group_Type" )
		}
		@else
		{
			Pop
		}
		

		
		@if ( IsLocalFlagSet( "Should Generate" ) )
		{
			ClearLocalFlag( "Should Generate" )

			/* Make sure index was not created as part of constraint. */
			[ IsPropertyTrue( "Generate_As_Constraint" )
				
				Set( "Key_Group_Type", Left( Property( "Key_Group_Type" ), "2" ) )
				@if ( Equal( Value( "Key_Group_Type" ), "PK" ) )
				{
					@if ( FE::Option( "PKConstraintInCreate" ) )
					{
						SetLocalFlag( "Constraint In Create" )
					}
					@else
					{
						/* Is entity index organized? */
						PushOwner
						[ NotEqual( ObjectType, "View" )
							@if ( IsPropertyEqual( "Oracle_Data_Storage_Type", "1" ) ) /* organization */
							{
								@if ( IsPropertyEqual( "Data_Organization_Type", "912" ) ) /* index */
								{
									SetLocalFlag( "Constraint In Create" , "1" )
								}
							}
						]
						Pop
					}
				}
				@elseif ( Equal( Value( "Key_Group_Type" ), "AK" ) )
				{
					FE::Option( "AKConstraintInCreate" )
					SetLocalFlag( "Constraint In Create" )
				}
				Remove( "Key_Group_Type" )

				@if ( IsLocalFlagSet( "Constraint In Create" ) )
				{
					FE::Option( "ConstraintState" )
					ForEachOwnee( "Oracle_Constraint_State" )
					{
						IsPropertyEqual( "Use_Index", "908" )
						SetLocalFlag( "Index Created In Constraint", "1" )
					}
					ClearLocalFlag( "Constraint In Create" )
				}
			]
			@ifnot ( IsLocalFlagSet( "Index Created In Constraint" ) )
			{
				FE::Bucket( "90" )
				< Execute( "Create Index" ) >
				FE::EndOfStatement                
			}
			@else
			{
				ClearLocalFlag( "Index Created In Constraint" )
			}
		}
	]

]

SPItemEnd

SPItemBegin [keep format] = Create Oracle_Cached_View_Log
/* Create materialized view log during  schema generation.      */
/* Assumes that the context is a Oracle Cached View Log object. */
[ ShouldGenerate
	OnceForObject( "Create Cached View Log" )
	FE::RecordCreate

	[ FE::Option( "TableCreateMaterializedViewLog" )    
		FE::Bucket( "90" ) 
		"CREATE MATERIALIZED VIEW LOG ON " PushOwner  [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop
		[ FE::Option( "MaterializedViewLogPhysicalStorage" ) Execute( "Clause: Physical Attributes" ) ]
		[ "\n\t" LookupProperty( "Oracle_Cache", "true", "CACHE", "false", "NOCACHE" ) ]
		[ "\n\t" LookupProperty( "Parallel_Mode", "904", "PARALLEL", "905", "NOPARALLEL" ) [ " " Property( "Oracle_Parallel_Threads" ) ] ]
		[ "\n\t" LookupProperty( "Oracle_No_Logging", "false", "LOGGING", "true", "NOLOGGING" ) ]
		[ FE::Option( "MaterializedViewLogPhysicalStorage") "\n\t" "TABLESPACE " QuotedNameThrough( "Oracle_Tablespace_Ref" ) ]
		[ FE::Option( "MaterializedViewLogPartitions" ) Execute( "Clause: Table Partition" ) ]
		["\n\t WITH " 
			<
				Separator( ","
					[ " " IsPropertyTrue( "Use_Object_Id" ) "OBJECT ID" ],
					[ " " IsPropertyTrue( "Use_Primary_Key" ) "PRIMARY KEY" ],
					[ " " IsPropertyTrue( "Use_Row_Id" ) "ROWID" ],
					[ " " IsPropertyTrue( "Use_Sequence" ) "SEQUENCE" ]
				)   
				[  "("
					<
						ForEachReference( "Columns_Ref" )
						{
							ListSeparator( "," )
							QuotedName
						}
					>
					")"
				]
			>
		]
		[ "\n\t" LookupProperty( "Disable_Recording_New_Values", "true", "EXCLUDING", "false", "INCLUDING" ) "  NEW VALUES" ]
		FE::EndOfStatement
	]
		
	 [ FE::Option( "Comments" )
		FE::Bucket( "90" ) 
		"COMMENT ON TABLE " PushOwner [ FE::OwnerOverride( "true" ) "." ] 
		[ FE::Option( "QuoteName" ) "\"" ] "MLOG$_" Property( "Physical_Name" ) [ FE::Option( "QuoteName" ) "\"" ]
		Pop " IS '"  
		/* truncate comment to 4000 characters */
		< Substitute( Left( Property( "Comment" ), "4000" ), "''", "'" ) >
		"'" 
		FE::EndOfStatement
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Cluster
/* Assumes that the context is Oracle cluster. */
[ ShouldGenerate
	OnceForObject( "Create Cluster" )
	FE::RecordCreate
	FE::Bucket( "75" ) FE::Option( "CreateCluster" )
	"CREATE CLUSTER " [ FE::OwnerOverride( "true" ) "." ] QuotedName
	"\n("
	<
		ForEachOwnee( "Oracle_Cluster_Column", "Object_Order" )
		{
			ListSeparator( "," )
			"\n\t" QuotedName  "  " Property( "Physical_Data_Type" ) "  "
			[ LookupProperty( "Time_Zone_Option", "904", "WITH TIME ZONE", "905", "WITH LOCAL TIME ZONE" ) "  " ] 
			[ IsPropertyTrue( "Oracle_Sort_Cluster_On_Column" ) "SORT" ]
		}
	>
	"\n)"
	[ Execute( "Clause: Physical Attributes" ) ]

	[ "\n\t" "SIZE " Property( "Oracle_Size" ) ]
	[ "\n\t" "TABLESPACE " QuotedNameThrough( "Oracle_Tablespace_Ref" ) ]
	[ "\n\t" IsPropertyTrue( "Oracle_Index_Cluster" ) "INDEX" ]
	[ "\n\t" [ IsPropertyTrue( "Is_Single_Table" )  "SINGLE TABLE" "  " ] "HASHKEYS " Property( "Oracle_Hash_Keys" ) [ " HASH IS  " Property( "Hash_Expression" ) ]  ]
	[ "\n\t" LookupProperty( "Parallel_Mode", "904", "PARALLEL", "905", "NOPARALLEL" ) "  " [  Property( "Oracle_Parallel_Threads" )  ]  ]
	[ "\n\t" LookupProperty( "Oracle_Has_Row_Dependencies", "true", "ROWDEPENDENCIES", "false", "NOROWDEPENDENCIES" ) ]
	[ "\n\t" LookupProperty( "Oracle_Cache", "true", "CACHE", "false", "NOCACHE") " " ]
	FE::EndOfStatement
]

/* Oracle cluster index. */
[
	ForEachOwnee( "Oracle_Cluster_Index" )
	{
		Execute( "Create Oracle_Cluster_Index" )
	}
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Cluster_Index
/* Assumes that the context is an Oracle cluster index object. */
[ ShouldGenerate
	OnceForObject( "Create Cluster Index" )
	FE::RecordCreate
	FE::Bucket( "75" ) FE::Option( "CreateClusterIndex" )
	"CREATE " 
	[ IsPropertyTrue( "Is_Unique" ) "UNIQUE" ] " INDEX " [ FE::OwnerOverride( "true" ) "." ] QuotedName
	" ON CLUSTER " [ PushOwner  [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop ]
	[ FE::Option( "CreateClusterIndexPhysicalStorage" ) 
		ForEachOwnee( "Oracle_Attribute_Storage" )
		{
			Execute( "Clause: Index Attributes" )
		}
	]
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Constraint_State
/* DESCRIPTION: Create Oracle constraint state during alter script generation.   */
/* Assumes the context object is a Oracle constraint state.                      */
[ PushOwner
	@ifnot ( IsCreated )
	{
		/* Owner is not created in this session. */				
		PushOwner
		[ Equal( ObjectType, "Entity" ) Pop 
			[ Equal( ObjectType, "Check_Constraint_Usage" ) Execute( "Generate Check_Constraint_Usage" ) ]
		]
		[ Equal( ObjectType, "Entity" ) Pop 
			[ Equal( ObjectType, "Key_Group" ) Execute( "Generate Key_Group" ) ]
		]
		[ Equal( ObjectType, "Attribute" ) Pop 
			[ Execute( "Generate Check_Constraint_Usage" ) ]
		]
	}
	Pop
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Context
/* DESCRIPTION: Create a context during schema generation.     */
/* Assumes the context object is a Oracle context.             */

[ ShouldGenerate
	OnceForObject( "Create Oracle_Context" )
	FE::RecordCreate
	FE::Bucket( "95" ) 
	FE::Option( "CreatePackageContext" )
	"CREATE " [ IsPropertyTrue( "Use_Replace_Syntax" ) "OR REPLACE " ] 
	" CONTEXT " QuotedName " USING " PushOwner [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop
	[ "\n\t" EnumProperty( "Type", "INITIALIZED EXTERNALLY", "ACCESSED GLOBALLY", "INITIALIZED GLOBALLY" ) ]
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Database
/* DESCRIPTION: Create a database during schema generation.     */
/* Assumes the context object is a Oracle database.             */
[ ShouldGenerate
	OnceForObject( "Create Oracle_Database" )
	FE::RecordCreate

	FE::Bucket( "10" )
	FE::Option( "CreateDatabase" )
	"CREATE DATABASE "   QuotedName
	["\n\t" IsPropertyTrue( "Oracle_Reuse_Control_File" ) "CONTROLFILE REUSE" ]
	["\n\t" "MAXDATAFILES " Property( "Oracle_Max_Data_Files" ) ]
	["\n\t" "MAXINSTANCES " Property( "Oracle_Max_Instances" ) ]
	["\n\t" "CHARACTER SET " Property( "Oracle_Character_Set" ) ]
	["\n\t" "NATIONAL CHARACTER SET " Property( "National_Character_Set" ) ]
	["\n\t" "SET DEFAULT " EnumProperty( "Storage_File_Type", "BIGFILE", "SMALLFILE" ) " TABLESPACE" ]
	["\n\t" "LOGFILE "
		<
			ForEachOwnee( "Oracle_Log_File", "Object_Order" )
			{
				ListSeparator( "," )
				["\n\t\t" "GROUP " Property( "Group_Id" ) ] 
				["\n\t\t" "(" FormatProperty( "File_Names", "b:'", "d: ," ) ")" ]
				["\n\t\t" "SIZE " Property( "Oracle_File_Size" ) ] 
				["\n\t\t" IsPropertyTrue( "Oracle_Can_Reuse_File" ) "REUSE" ] 
			}
		>
	]
	["\n\t" "MAXLOGFILES " Property( "Oracle_Max_Log_Files" ) ]
	["\n\t" "MAXLOGMEMBERS " Property( "Oracle_Max_Log_Members" ) ]
	["\n\t" "MAXLOGHISTORY " Property( "Oracle_Max_Log_History" ) ]
	["\n\t" LookupProperty( "Oracle_Archive_Log", "true", "ARCHIVELOG", "false", "NOARCHIVELOG" ) ]
	["\n\t" IsPropertyTrue( "Force_Logging" ) "FORCE LOGGING" ]
	["\n\t" "EXTENT MANAGEMENT " LookupProperty( "Extent_Management_Type", "1", "LOCAL" ) ]
	[ PushReference( "Oracle_System_Tablespace_Ref" )
		["\n\t" "DATAFILE "
			<
				ForEachOwnee( "Oracle_Physical_File", "Object_Order" )
				{
					ListSeparator( ",\n" )
					Execute( "Clause: Physical File Spec" )
				}
			>
		]
		["\n\t" "EXTENT MANAGEMENT " LookupProperty( "Extent_Management_Type", "923", "LOCAL" ) ]
		Pop
	]

	/* Tablespace clauses. */
	[ PushReference( "Auxiliary_Oracle_Tablespace_Ref" )
		["\n\t" "SYSAUX DATAFILE " 
			<
				ForEachOwnee( "Oracle_Physical_File", "Object_Order" )
				{
					ListSeparator( ",\n" )
					Execute( "Clause: Physical File Spec" )
				}
			>
		]
		Pop
	]

	["\n\t" PushReference( "Default_Tablespace_Ref" )
		"DEFAULT TABLESPACE " QuotedName
		["\n\t" "DATAFILE "
			<
				ForEachOwnee( "Oracle_Physical_File", "Object_Order" )
				{
					ListSeparator( ",\n" )
					Execute( "Clause: Physical File Spec" )
				}
			>
		]
		[ "\n\t" "EXTENT MANAGEMENT " LookupProperty( "Extent_Management_Type", "922", "DICTIONARY", "923", "LOCAL" )
			["  " LookupProperty( "Local_Extent_Management_Type", "920", "AUTOALLOCATE", "921", "UNIFORM" ) 
				[ " " "SIZE " Property( "Extent_Size" ) ] 
			] 
		]
		Pop
	]

	["\n\t" PushReference( "Default_Temporary_Tablespace_Ref" )
		[ EnumProperty( "Storage_File_Type", "BIGFILE", "SMALLFILE" ) " " ] "DEFAULT TEMPORARY TABLESPACE " QuotedName 
		[ "\n\t" "TEMPFILE " 
			<
				ForEachOwnee( "Oracle_Physical_File", "Object_Order" )
				{
					ListSeparator( ",\n" )
					Execute( "Clause: Physical File Spec" )
				}
			>
		]
		[ "\n\t" "EXTENT MANAGEMENT " LookupProperty( "Extent_Management_Type", "920", "DICTIONARY", "923", "LOCAL" )
			[ "  " LookupProperty( "Local_Extent_Management_Type", "920", "AUTOALLOCATE", "921", "UNIFORM" ) 
				[ " " "SIZE " Property( "Extent_Size" ) ]
			]
		]
		Pop
	]
	[ "\n\t" PushReference( "Undo_Tablespace_Ref" )
		[ LookupProperty( "Storage_File_Type", "0", "BIGFILE", "1", "SMALLFILE" ) " " ] "UNDO TABLESPACE " QuotedName 
		[ "\n\t" "DATAFILE " 
			<
				ForEachOwnee( "Oracle_Physical_File", "Object_Order" )
				{
					ListSeparator( ",\n" )
					Execute( "Clause: Physical File Spec" )
				}
			>
		]
		Pop
	]
	[ "\n\t" "SET TIME_ZONE='" Property( "Time_Zone" ) "'" ]
	FE::EndOfStatement
]
/* Are we generating database-level triggers? */
[	FE::Bucket( "110" )
	FE::Option( "CreateDatabaseTrigger" ) 
	ForEachOwnee( "Trigger" )
	{
		[ ShouldGenerate
			Execute( "Create Trigger" ) 
		]
	}
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Database_Link
/* DESCRIPTION: Create a database link during schema generation.     */
/* Assumes the context object is a Oracle database link.             */
[ ShouldGenerate
	OnceForObject( "Create Oracle_Database_Link" )

	FE::Option( "CreateDatabaseLink" )
	FE::Bucket( "20" )
	FE::RecordCreate
	"CREATE " [ IsPropertyTrue( "Is_Shared" ) "SHARED" " " ] 
	[ IsPropertyTrue( "Oracle_Is_Public" ) "PUBLIC" " " ]  
	" DATABASE LINK " QuotedName
	["\n\t" IsPropertyEqual( "Connection_Type", "0" ) "CONNECT TO CURRENT_USER" 
		[" AUTHENTICATED BY " [ FE::Option( "QuoteName" ) "\"" ] Property( "Use_Authenticated_User" ) [ FE::Option( "QuoteName" ) "\"" ] " IDENTIFIED BY GeneratePassword " ]
	]
	["\n\t" IsPropertyEqual( "Connection_Type", "1" ) [ "CONNECT TO " [ FE::Option( "QuoteName" ) "\"" ] Property( "User" ) [ FE::Option( "QuoteName" ) "\"" ]  " IDENTIFIED BY GeneratePassword "] 
		[" AUTHENTICATED BY " [ FE::Option( "QuoteName" ) "\"" ] Property( "Use_Authenticated_User" ) [ FE::Option( "QuoteName" ) "\"" ] " IDENTIFIED BY GeneratePassword " ]
	]
	["\n\t" IsPropertyEqual( "Connection_Type", "2" ) "AUTHENTICATED BY " [ FE::Option( "QuoteName" ) "\"" ] Property( "Use_Authenticated_User" ) [ FE::Option( "QuoteName" ) "\"" ] " IDENTIFIED BY GeneratePassword " ]
	["\n\t" "USING " "'" Property( "Connection_String" ) "'" ]
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Directory
/* DESCRIPTION: Create a database directory during schema generation.     */
/* Assumes the context object is a Oracle database directory.             */
[ ShouldGenerate
	OnceForObject( "Create Oracle_Directory" )
	FE::Bucket( "15" ) FE::Option( "CreateDirectory" )
	FE::RecordCreate
	"CREATE " 
	[ IsPropertyTrue( "Use_Replace_Syntax" ) "OR REPLACE " ] 
	" DIRECTORY "  QuotedName
	"\n\t" "AS " "'" Property( "Path" ) "'"
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Disk_Group
/* DESCRIPTION: Create a disk group during schema generation.     */
/* Assumes the context object is a Oracle disk group.             */
[ ShouldGenerate
	OnceForObject( "Create Oracle_Disk_Group" )
	FE::Bucket( "5" ) FE::Option( "CreateDiskgroup" ) 
	FE::RecordCreate
	"CREATE DISKGROUP "   QuotedName
	[ "\n\t" EnumProperty( "Redundancy_Type", "HIGH", "NORMAL", "EXTERNAL" ) " REDUNDANCY" ]
	<
		ForEachOwnee( "Oracle_Fail_Group" )
		{
			"\n\t" [ "FAILGROUP " IsPropertyNull( "Is_Unnamed" ) QuotedName " " ] "DISK "
			<
				ForEachOwnee( "Oracle_Qualified_Disk" )				
				{
					ListSeparator( "," )
					"\n\t\t" "'" Property( "Search_String" ) "'" [ IsPropertyNull( "Is_Unnamed" )  " NAME " Property( "Name" ) ]
					[ " SIZE " Property( "Oracle_Size" ) ] 
					[ " " LookupProperty( "Force_Add", "true", "FORCE", "false", "NOFORCE" ) ]
				}
			>
		}
	>
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Library
/* DESCRIPTION: Create a library during schema generation.     */
/* Assumes the context object is a Oracle library.             */
[ ShouldGenerate
	OnceForObject( "Create Oracle_Library" )

	FE::Option( "CreateLibrary" )  
	FE::RecordCreate
	FE::Bucket( "25" )
	"CREATE " [ IsPropertyTrue( "Use_Replace_Syntax" ) "OR REPLACE " ] "LIBRARY "  
	[ FE::OwnerOverride( "true" ) "." ] QuotedName
	"\n\t" "AS " "'" Property( "File_Name" ) "'"
	[ "\n\t" "AGENT " "'"
		/* Library Agent Properties */
		<
			[
				PushReference( "Database_Link_Ref" )
					[ QuotedName ]
				Pop
			]
		>
		"'"
	]
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Package
/* DESCRIPTION: Create a Oracle package during schema generation.     */
/* Assumes the context object is an Oracle package.                   */
[ ShouldGenerate
	OnceForObject( "Create Oracle_Package" )
	FE::RecordCreate			
	FE::Option( "CreatePackage" ) 
	[ FE::Bucket( "95" )
        FE::ExpandERwinMacro( "Template_Specification" )
		"\n\/\n\n"
		FE::EndOfStatement( "true" )
	]
	
	[ FE::Bucket( "95" )
        FE::ExpandERwinMacro( "Template_Code" )
		"\n\/\n\n"
		FE::EndOfStatement( "true" )
	]
]
[
	ForEachOwnee( "Oracle_Context" )
	{
		Execute( "Create Oracle_Context" )
	}
]

/* Are we creating synonyms? */
[ FE::Option( "CreatePackageSynonym" ) 
	FE::Bucket( "95" )
	ForEachOwnee( "Synonym" )
	{
		ShouldGenerate
		Execute( "Create Synonym" )
	}
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Rollback_Segment
/* DESCRIPTION: Create a Oracle rollback segment during schema generation.     */
/* Assumes the context object is an Oracle rollback segment.                   */

[  ShouldGenerate
	OnceForObject( "Create Oracle_Rollback_Segment" )
	
	FE::Option( "CreateRollbackSeg")  
	FE::Bucket( "70" ) 

	FE::RecordCreate
	"CREATE " [ IsPropertyTrue( "Oracle_Is_Public" ) "PUBLIC" ] " ROLLBACK SEGMENT " QuotedName
	[ "\n\t" "TABLESPACE " PushReference( "Oracle_Tablespace_Ref" ) QuotedName Pop ]
	[
		" STORAGE ( "
		< 
			[
				[ "\n\t\t" "INITIAL " < Property("Oracle_Initial_Extent_Size") > ]
				[ "\n\t\t" "NEXT " < Property( "Oracle_Next_Extent_Size" ) > ]
				[ "\n\t\t" "MINEXTENTS " < Property( "Oracle_Min_Extents" ) > ]
				[ "\n\t\t" "MAXEXTENTS " 
					<
						[ IsPropertyEqual("Oracle_Max_Extent_Type", "0") "UNLIMITED" ]
						[ Property( "Oracle_Max_Extents" ) ]
					>
				]
				[ "\n\t\t" "PCTINCREASE " < Property( "Oracle_Percent_Increase" ) > ]
				[ "\n\t\t" "FREELISTS " < Property( "Oracle_Free_Lists" ) > ]
				[ "\n\t\t" "FREELIST GROUPS " < Property( "Oracle_Free_List_Groups" ) > ]
				[ "\n\t\t" "OPTIMAL " 
					[ IsPropertyEqual( "Oracle_Optimal_Size_Type", "0" ) "NULL " ]
						< Property( "Oracle_Optimal_Size" ) > 
				]
			]
		>
		"\n\t )" 
	]
	FE::EndOfStatement

	[ "ALTER ROLLBACK SEGMENT " QuotedName
		" " LookupProperty( "Oracle_Is_Offline", "true", "OFFLINE", "false", "ONLINE" )
		FE::EndOfStatement
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Oracle_Tablespace
/* DESCRIPTION: Create a Oracle tablespace during schema generation.     */
/* Assumes the context object is an Oracle tablespace.                   */

[ ShouldGenerate 
	OnceForObject( "Create Oracle_Tablespace" )

	FE::Option( "CreateTablespace" ) 
	FE::RecordCreate
	/* Extent Management Type is Local or not specified. */
	[	
		@ifnot ( IsPropertyEqual( "Extent_Management_Type", "922" ) )
		{
			[ FE::Bucket( "65" )
				"CREATE " 
				[ EnumProperty( "Storage_File_Type", "BIGFILE", "SMALLFILE" ) ] 
				[ EnumProperty( "Tablespace_Type", " UNDO", " TEMPORARY" ) ]
				" TABLESPACE " QuotedName
				[ IsPropertyEqual( "Tablespace_Type", "2" ) Execute( "Clause: Permanent Tablespace" ) ]
				[ IsPropertyEqual( "Tablespace_Type", "1" ) Execute( "Clause: Temporary Tablespace" ) ]
				[ IsPropertyEqual( "Tablespace_Type", "0" ) Execute( "Clause: Undo Tablespace" ) ]
				FE::EndOfStatement
			]
		}
	]

	/* Extent Management Type is Dictionary. */
	[ IsPropertyEqual( "Extent_Management_Type", "922" )
		[ FE::Bucket( "65" )
			"CREATE " 
			[ EnumProperty( "Storage_File_Type", "BIGFILE", "SMALLFILE" ) ] 
			[ LookupProperty( "Tablespace_Type", "0", " UNDO") ] 
			" TABLESPACE " QuotedName
			[ Execute( "Clause: Permanent Tablespace" ) ]
			FE::EndOfStatement
		]
	]

	[ FE::Bucket( "65" )
		"ALTER TABLESPACE " QuotedName
		"\n\t" LookupProperty( "Is_Read_Only", "true", "READ ONLY", "false", "READ WRITE" )
		FE::EndOfStatement
	]

	/* Is file offline? */
	[ FE::Bucket( "65" )
		ForEachOwnee( "Oracle_Physical_File" )
		{
			@if ( IsPropertyTrue( "Oracle_Is_Offline" ) )
			{
				SetLocalFlag( "File Offline", "1" )
			}
		}

		@if( IsLocalFlagSet( "File Offline" ) )
		{
			"ALTER TABLESPACE " QuotedName
			"\n\t"
			@if ( IsPropertyTrue( "Tablespace_Type","1" ) )
			{
				LookupProperty( "Extent_Management_Type", "923", "TEMPFILE OFFLINE ","922", "DATAFILE OFFLINE ", "TEMPFILE OFFLINE " )
			}
			@else
			{
				"DATAFILE OFFLINE "
			}
			FE::EndOfStatement
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Sequence
/* DESCRIPTION: Create a Oracle sequence during schema generation.     */
/* Assumes the context object is an Oracle sequence.                   */
[ ShouldGenerate
	OnceForObject( "Create Sequence" )

	FE::Option( "CreateSequence" )

	FE::Bucket( "35" ) 
	FE::RecordCreate
	"CREATE SEQUENCE " [ FE::OwnerOverride( "true" ) "." ] QuotedName
	[ "\n\t" "INCREMENT BY " Property( "Increment_By" ) ]
	[ "\n\t" "START WITH " Property( "Starting_Value" ) ]
	[  LookupProperty( "Is_Max", "false", "\n\t" "NOMAXVALUE", "true", ["\n\t" "MAXVALUE "  <Property( "Max_Value" )> ] ) ]
	[  LookupProperty( "Is_Min", "false", "\n\t" "NOMINVALUE", "true",[ "\n\t" "MINVALUE "  <Property( "Min_Value" )> ] ) ]
	[ "\n\t" LookupProperty( "Is_Cycle_On", "true", "CYCLE", "false", "NOCYCLE" ) ]
	[  LookupProperty( "Is_Cache_On", "false", "\n\t" "NOCACHE", "true", ["\n\t" "CACHE " <Property( "Cache_Capacity" )> ] ) ]
	[ "\n\t" LookupProperty( "Order_On", "true", "ORDER", "false", "NOORDER" ) ] 
	FE::EndOfStatement
]

/* Are we creating synonym for this object? */
[ FE::Option("SequenceCreateSynonym")
	FE::Bucket( "35" )
	ForEachOwnee( "Synonym" )
	{
		ShouldGenerate
		Execute( "Create Synonym" )
	}
]
SPItemEnd

SPItemBegin [keep format] = Create Stored_Procedure
/* DESCRIPTION: Create a procedure during schema generation.      */
/* Assumes the context object is a procedure.					  */
[ ShouldGenerate
	OnceForObject( [ Repush( "1" ) ObjectId Pop ] "Create Stored_Procedure" )

	FE::RecordCreate	
	FE::Bucket( "100" )
	@if(Equal( Property( "Type" ), "Table Level" ))
	{
		@if( IsPropertyTrue( "Generate_As_Pre_Script" ) )
		{
			FE::Bucket( "57" )
		}
		@else
		{
			FE::Bucket( "100" )
		}
	}
	
    FE::ExpandERwinMacro( "Template_Code" )
	"\n\/\n\n" 
	FE::EndOfStatement( "true" )
]
[ FE::Option( "TableCreateProcedureSynonym" )
	FE::Bucket( "100" )
	ForEachOwnee( "Synonym" )
	{
		ShouldGenerate
		Execute( "Create Synonym" )
	}
]
SPItemEnd

SPItemBegin [keep format] = Create Synonym
/* DESCRIPTION: Create a synonym during schema generation.      */
/* Assumes the context object is a synonym.					   */
[
	[ ShouldGenerate
		OnceForObject( "Create Synonym" )

		FE::RecordCreate
		"CREATE " 
		[ DBMSVersion( "9", "10" ) IsPropertyTrue( "Use_Replace_Syntax" ) "OR REPLACE " ]
		[ IsPropertyTrue( "Oracle_Is_Public_Synonym" ) "PUBLIC" " " ]  
		"SYNONYM " [ FE::OwnerOverride( "true" ) "." ] QuotedName
		"\n\t"  " FOR " 
		[ PushOwner  [ NotEqual( ObjectType, "Model") [ FE::OwnerOverride( "true" ) "." ] QuotedName ] Pop ]
		[ [ FE::Option( "SpecifyOwner" ) [ FE::Option( "QuoteName" ) "\"" ] Property( "Remote_Object_Owner" )  [ FE::Option( "QuoteName" ) "\"" ]  "." ] 
			[ FE::Option( "QuoteName" ) "\"" ] Property( "Remote_Object_Name" ) [ FE::Option( "QuoteName" ) "\"" ]
			["@" < PushReference( "Oracle_Database_Link_Ref" ) [ QuotedName ] Pop > ]
		]
		FE::EndOfStatement
	]
	[
		ForEachOwnee( "Synonym" )
		{
			ShouldGenerate
			Execute( "Create Synonym" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Create Trigger
/* DESCRIPTION: Create a trigger during schema generation.     */
/* Assumes the context object is a trigger.					   */
[
	/* To Ensure Trigger to be generated only when User defined option is checked */
	FE::Option ( "GenerateUserDefinedTrigger" )
	PushOwner
	@if( Equal( ObjectType, "Oracle_Database" ) )
	{
		SetLocalFlag( "Database Owner" )
	}
	Pop

	[ ShouldGenerate
		@ifnot( IsLocalFlagSet( "Database Owner" ) )
		{
			OnceForObject( "Create Trigger" )
			FE::RecordCreate
			FE::Bucket( "115" )
			<@if ( IsDefaultRITrigger )
			{
				"\n" Property( "Trigger_Body", "no_translate" )
			}
			@else
			{
                "\n" FE::ExpandERwinMacro( "Trigger_Body" ) "\n/"
			}>
			FE::EndOfStatement( "true" )
		}
	]

	[
		@if ( IsLocalFlagSet( "Database Owner" ) )
		{
			OnceForObject( "Create Trigger" )
			FE::RecordCreate
			FE::Bucket( "115" )
            "\n" FE::ExpandERwinMacro( "Trigger_Body" )"\n/"
			FE::EndOfStatement( "true" )
		}
	]

	[ FE::Bucket( "115" )
		"\n\nALTER TRIGGER " [ FE::OwnerOverride( "true" ) "." ] QuotedName
		"\n\t" LookupProperty( "Trigger_Status", "0", "ENABLE", "1", "DISABLE" )
		FE::EndOfStatement
	]
]
SPItemEnd

SPItemBegin [keep format] = Create View
/* DESCRIPTION: Create a view during schema generation.         */
/* Assumes the context object is a view.                        */
[ ShouldGenerate
	OnceForObject( "Create View" )

	/* Is "ViewPreScript" option turned on? */
	[ FE::Option( "ViewPreScript" )
		ForEachReference( "Script_Templates_Ref" )
		{
			[ ShouldGenerate IsPropertyTrue( "Generate_As_Pre_Script" )
				FE::Bucket( "90" )
                FE::ExpandERwinMacro( "Template_Code" )
				FE::EndOfStatement( "true" )
			]
		}
	]

	/* Is "CreateView" option turned on? */
	[ FE::Option( "CreateView" )
		FE::RecordCreate
		FE::Bucket( "90" )
		<
			@if ( IsPropertyNotNull( "User_Defined_SQL" ) )
			{
				/* User defined view. Emit the view SQL. */
				Property( "User_Defined_SQL" )
			}
			@else
			{
				/* Erwin generated view. */
				[
					"CREATE " 
					[ IsPropertyTrue( "Use_Replace_Syntax" )  "OR REPLACE " ] 
					[ LookupProperty( "Force_Create", "true"," FORCE", "false", " NOFORCE" ) ] 
					" VIEW " [ FE::OwnerOverride( "true" ) "." ] QuotedName
					[
						" ( "
						<
							ForEachReference( "Physical_Columns_Order_Ref" )
							{
								ShouldGenerate
								ListSeparator( "," )
								QuotedName
							}               
						>
						" ) "
					]
					"\n\t"
					" AS "  
					/* Select statement */
				
					" SELECT " 
					[ EnumProperty2( "Select_Type", "1", "ALL", "DISTINCT", "UNIQUE" ) " " ]    
					/* View columns. */
					<
						ForEachReference( "Physical_Columns_Order_Ref" )
						{
							ShouldGenerate
							ListSeparator( "," )
							[ PushReference( "Parent_Relationship_Ref" )
								@if ( IsPropertyNotNull( "Alias_Name" ) )
								{
									[ FE::Option( "QuoteName" ) "\"" ] Property( "Alias_Name" ) [ FE::Option( "QuoteName" ) "\"" ] "."
								}
								@else
								{
									PushReference( "Parent_Entity_Ref" )
									[ [ FE::OwnerOverride( "true" ) "."  ] 
										QuotedName "."
									]
									Pop
								}
								Pop
								
								PushReference( "Parent_Attribute_Ref" )
								[ PushOwner
									@if ( Equal( ObjectType, "Entity" ) )
									{
										/* Entity attribute. */
										Pop
										QuotedName
									}
									@else
									{
										/* View Attribute. */
										Pop
										QuotedName
									}
								]
								Pop
							]
							[ Property( "View_Expression" ) ]
						}
					>
					"\n\t\t" "FROM "
					/* From clause. */
					<
						ForEachReference( "Child_Relationships_Ref" )
						{
							ShouldGenerate
							ListSeparator( "," )
							[ PushReference( "Parent_Entity_Ref" )
								[ FE::OwnerOverride( "true" ) "." ] QuotedName
								Pop
							]
							[ " " Property( "Alias_Name" ) ]
						}
					>   
						
					[ "\n\t\t" "WHERE " Property( "Where_Clause" )]
					[ "\n\t\t" [ "START WITH " Property( "Start_With_Condition" ) " " ] "CONNECT BY " [ IsPropertyTrue( "No_Cycle" ) "NOCYCLE" " " ] Property( "Hierarchical_Condition" ) ]
					[ "\n\t\t" "GROUP BY " Property( "Group_By_Clause" ) ]
					[ "\n\t\t" "HAVING " Property( "Having_Clause" ) ]
					[ "\n\t\t" "ORDER BY " Property( "Order_By_Clause" ) ]
		
					[ "\n\t\t" LookupProperty( "Restriction_Type", "2", "WITH READ ONLY" ) ]
					[ "\n\t\t" LookupProperty( "Restriction_Type", "1", "WITH CHECK OPTION" ) ]
					[ " CONSTRAINT " Property( "Oracle_Constraint" ) ]
				]
			}
		>
		FE::EndOfStatement
	]

	/* Are we generating comments?  */
	[ FE::Option( "Comments" )
		
		/* Generate the table-level comment.    */
		[ FE::Bucket( "90" )
			"COMMENT ON TABLE "
			[ FE::OwnerOverride( "true" ) "."  ] QuotedName
			" IS '" < Substitute( Left( Property( "Definition" ), "4000" ), "''", "'" ) > "'"
			FE::EndOfStatement
		]

		/* Generate the column-level comments.  */
		[
			ForEachReference( "Physical_Columns_Order_Ref" )
			{
				[ FE::Bucket( "90" )
					"COMMENT ON COLUMN "
					[ FE::OwnerOverride( "true", "1" ) "." ] 
					OwnerQuotedName "." QuotedName
					" IS '" < Substitute( Left( Property( "Comment" ), "4000" ), "''", "'" ) > "'"
					FE::EndOfStatement
				]   
			}
		]
	]

	/* Are we generating synonyms? */
	[ FE::Option( "ViewCreateSynonym" ) FE::Bucket( "90" )
		ForEachOwnee( "Synonym" )
		{
			ShouldGenerate
			Execute( "Create Synonym" )
		}
	]   

	/* View constraints. */
	[ FE::Option( "CreateView" )
		IsPropertyNull( "User_Defined_SQL" )
		ForEachOwnee( "Key_Group" )
		{
			[ FE::Bucket( "90" )
				"ALTER VIEW " PushOwner [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop
				"\n\t" "ADD "  < Execute( "Clause: PK Constraint" ) >
				FE::EndOfStatement
			] 
		}
	]

	[ FE::Option( "CreateView" )
		IsPropertyNull( "User_Defined_SQL" )
		ForEachOwnee( "Key_Group" )
		{
			[ FE::Bucket( "90" )
				"ALTER VIEW " PushOwner [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop
				"\n\t" "ADD "  < Execute( "Clause: AK Constraint" ) >
				FE::EndOfStatement
			] 
		}
	]

	[ FE::Option( "CreateView" )
		IsPropertyNull( "User_Defined_SQL" )
		ForEachOwnee( "Key_Group" )
		{
			[ FE::Bucket( "90" )
				"ALTER VIEW " PushOwner [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop
				"\n\t" "ADD "  < Execute( "Clause: View FK Constraint" ) >
				FE::EndOfStatement
			] 
		}
	]

	/* Stored procedures.   */
	[  
		ForEachReference( "Stored_Procedures_Ref" )
		{
			/* Make sure they should generate and that they are a table-level procedure.    */
			[ ShouldGenerate Equal( Property( "Type" ), "Table Level" )
				[ FE::Option( "ViewDropProcedureSynonym" )
					FE::Bucket( "100" ) 
					ForEachOwnee( "Synonym" )
					{
						ShouldGenerate
						Execute( "Drop Synonym" )
					}
				]
				[ FE::Option( "ViewDropStoredProcedure" ) Execute( "Drop Stored_Procedure" ) ]
				[ FE::Option( "ViewCreateStoredProcedure" ) Execute( "Create Stored_Procedure" ) ]
				[ FE::Option( "ViewCreateProcedureSynonym" )
					FE::Bucket( "100" ) 
					ForEachOwnee( "Synonym" )
					{
						ShouldGenerate
						Execute( "Create Synonym" )
					}
				]
			]
		}
	]

	/* Table-level functions.   */
	[
		ForEachReference( "Functions_Ref" )
		{
			/* Make sure they should generate and that they are a table-level function.    */
			[ ShouldGenerate Equal( Property( "Type" ), "Table Level" )
				[ FE::Option( "ViewDropFunctionSynonym" )
					FE::Bucket( "100" ) 
					ForEachOwnee( "Synonym" )
					{
						ShouldGenerate
						Execute( "Drop Synonym" )
					}
				]
				[ FE::Option( "ViewDropFunction" ) Execute( "Drop Function" ) ]
				[ FE::Option( "ViewCreateFunction" ) Execute( "Create Function" ) ]
				[ FE::Option( "ViewCreateFunctionSynonym" )
					FE::Bucket( "100" ) 
					ForEachOwnee( "Synonym" )
					{
						ShouldGenerate
						Execute( "Create Synonym" )
					}
				]
			]
		}
	]

	/* Tirggers. */
	[ FE::Option( "ViewCreateTrigger" )
		ForEachOwnee( "Trigger" )
		{
			ShouldGenerate
			Execute( "Create Trigger" )
		}
	]

	/* View post script. */
	[ FE::Option("ViewPostScript") 
		ForEachReference( "Script_Templates_Ref" )
		{
			[ ShouldGenerate IsPropertyFalse( "Generate_As_Pre_Script" )
				FE::Bucket("90")
                FE::ExpandERwinMacro( "Template_Code" )
				FE::EndOfStatement( "true" )
			]
		}
	]

	/* During alter script generation, recreate dependent views. */
	[ FE::IsAlterScriptGeneration
		ForEachReference( "Parent_Relationships_Ref" )
		{
			PushReference( "Child_Entity_Ref" )
			[ Equal( ObjectType, "View" )
				@ifnot ( IsDeleted )
				{
					Execute( "Create View" )
				}
			]
			Pop
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Drop Attribute
/* DESCRIPTION: Alter table to drop an attribute during alter script generation. */
/* Assumes the context object is an attribute.                                  */
[
	PushOwner
	@if ( Equal ( ObjectType, "Entity" ) )
	{
		@ifnot ( IsDeleted )
		{
			/* Entity was not deleted in this session. */
			FE::Bucket( "40" ) "\n"
			FE::RecordAlter
			"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName Pop
			"\n"
			"  DROP COLUMN " Execute( "Previous Physical Name" ) " CASCADE CONSTRAINTS"
			FE::EndOfStatement
		}
		@else
		{
			Pop
		}
	}
	@else
	{
		Pop
	}
]
SPItemEnd

SPItemBegin [keep format] = Drop Cached_View
/* DESCRIPTION: Drop a materialized view during schema generation.    */
/* Assumes the context object is a cached view.                       */ 
[ ShouldGenerate
	OnceForObject( "Drop Cached_View" )

	[ FE::Option( "CachedViewDropTrigger" ) 
		ForEachOwnee( "Trigger" )
		{
			[ ShouldGenerate
				Execute( "Drop Trigger" )
			]
		}
	]

	[ FE::Option( "CachedViewDropSynonym" )
		FE::Bucket( "40" )
		ForEachOwnee( "Synonym" )
		{
			ShouldGenerate
			Execute( "Drop Synonym" )
		}
	]

	[ FE::Bucket( "40" )
		FE::Option( "DropCachedView" )
		"DROP MATERIALIZED VIEW "  [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Name" )
		FE::EndOfStatement
	]

]
SPItemEnd

SPItemBegin [keep format] = Drop Check_Constraint_Usage
/* DESCRIPTION: Drop a check constraint usage during alter script generation.   */
/* Assumes the context object is a check constraint usage.                        */
[
	OnceForObject("Drop Check_Constraint_Usage")
	PushOwner
	@if ( Equal( ObjectType, "Attribute" ) )
	{
		/* Column-level check constraint. */
		@ifnot ( IsDeleted )
		{
			Pop 
			
			/* The current context is check constraint usage. */

			FE::Bucket( "11" ) "\n"
			PushOwner PushOwner
			FE::RecordAlter
			"ALTER TABLE "  [ FE::OwnerOverride( "true" ) "." ] QuotedName  "\n\t"  Pop Pop
			"DROP CONSTRAINT "  QuotedName
			FE::EndOfStatement
		}
		@else
		{
			/* The attribute was deleted. */
			Pop
		}
	}
	@elseif ( Equal( ObjectType, "Entity" ) )
	{
		/* Table-level check constraint. */
		@ifnot ( IsDeleted ) 
		{
			FE::Bucket( "11" )
			FE::RecordAlter
			"ALTER TABLE " [ FE::OwnerOverride( "true" ) "." ] QuotedName      
			Pop
			"\nDROP CONSTRAINT " QuotedName
			FE::EndOfStatement
		}
		@else
		{
			/* The entity was deleted. */
			Pop
		}
	}
	@else
	{   
		/* Cannot be here. */
		Pop
	}
]
SPItemEnd

SPItemBegin [keep format] = Drop Constraint
/* DESCRIPTION: Drop an PK, AK, or FK constraint during alter script generation.   */
/* Assumes the context object is a key group.                                      */
[
	[ FE::Option( "PKConstraintInAlter" )
		IsPropertyTrue( "Generate_As_Constraint" )
		Equal( Left( Property( "Key_Group_Type" ), "2" ), "PK" )
		OnceForObject( "Drop Constraint" )
		FE::Bucket( "37" )
		PushOwner		
		[ Equal( ObjectType, "View" )
			
			"ALTER VIEW " [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" )
			Pop
			"\nDROP CONSTRAINT " 
			< Execute( "Previous Property Value", "", "Constraint_Name" ) >
			FE::EndOfStatement
		]
		[ Equal( ObjectType, "Entity" ) 
			"ALTER TABLE " [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" )
			Pop
			"\nDROP PRIMARY KEY CASCADE " [ DBMSVersion( "10" ) " DROP INDEX" ]
			FE::EndOfStatement
		]		
	]

	[ FE::Option( "AKConstraintInAlter" )
		IsPropertyTrue( "Generate_As_Constraint" )
		Equal( Left( Property( "Key_Group_Type" ), "2" ), "AK" )
		OnceForObject( "Drop Constraint" )
		FE::Bucket( "37" )
		PushOwner		
		[ Equal( ObjectType, "View" )
			"ALTER VIEW " [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" )
			Pop
			"\nDROP CONSTRAINT " 
			< Execute( "Previous Property Value", "", "Constraint_Name" ) >
			FE::EndOfStatement
		]
		[ Equal( ObjectType, "Entity" )
			"ALTER TABLE " [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" )
			Pop
			"\nDROP CONSTRAINT " 
			< Execute( "Previous Property Value", "", "Constraint_Name" ) > 
			" CASCADE "[ DBMSVersion( "10" ) " DROP INDEX" ]
			FE::EndOfStatement
		]		
	]

	[ FE::Option( "FKConstraintInAlter" )
		IsPropertyTrue( "Generate_As_Constraint" )
		Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )
		OnceForObject( "Drop Constraint" )
		FE::Bucket( "36" )
		PushOwner
		@if( ShouldGenerate )
		{
			[ Equal( ObjectType, "View" )
				"ALTER VIEW " [  < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" )
				Pop
				"\nDROP CONSTRAINT " 
				< Execute( "Previous Property Value", "", "Constraint_Name" ) >
				FE::EndOfStatement
			]
			[ Equal( ObjectType, "Entity" )
				"ALTER TABLE " [  < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" )
				Pop
				"\nDROP CONSTRAINT " 
				< PushReference( "Relationship_Ref" ) Execute( "Previous Physical Name" ) Pop >
				FE::EndOfStatement
			]
		}
		@else
		{
			Pop
		}
	]
]

SPItemEnd

SPItemBegin [keep format] = Drop Default_Constraint_Usage
/* DESCRIPTION: Drop a default constraint usage during alter script generation.   */
/* Assumes the context object is a default constraint usage.                      */
[ OnceForObject( "Drop Check_Constraint_Usage" )
	PushOwner

	/* Do not alter if the entire attribute was dropped. */
	@ifnot( IsDeleted )
	{
		Pop

		/* The attribute was not deleted - just remove the default. */
		FE::Bucket( "11" ) "\n"
		PushOwner PushOwner
		FE::RecordAlter
		"ALTER TABLE "  [ FE::OwnerOverride( "true") "." ] QuotedName  Pop "\n\t"   
		"MODIFY " QuotedName " DEFAULT NULL "
		Pop
		FE::EndOfStatement
	}
	@else
	{
		Pop

		/* The entire attribute was deleted. */
	}
]
SPItemEnd

SPItemBegin [keep format] = Drop Entity
/* DESCRIPTION: Drop an entity during schema generation.        */
/* Assumes the context object is an entity.                     */ 
[ ShouldGenerate
	OnceForObject( "Drop Entity" )

	/* Drop owned indexes. */
	[ FE::Bucket( "40" )
		ForEachOwnee( "Key_Group" )
		{
			Execute( "Drop Key_Group" )
		}
	]
	
	[
		ForEachOwnee( "Oracle_Cached_View_Log" )
		{
			[ ShouldGenerate
				Execute( "Drop Oracle_Cached_View_Log" )
			]
		}
	]

	/* Are we dropping user defined table triggers? */
	[ FE::Option( "TableDropTrigger" )
		FE::Bucket( "40" )
		ForEachOwnee( "Trigger" )
		{
			[ ShouldGenerate
				Execute( "Drop Trigger" )
			]
		}
	]
	
	/* Are we dropping synonyms? */
	[ FE::Option( "TableDropSynonym" )
		FE::Bucket( "40" )
		ForEachOwnee( "Synonym" )
		{
			[ ShouldGenerate
				Execute( "Drop Synonym" )
			]
		}
	]

	/* Is DropTable option turned on? */
	[ FE::Option( "DropTable" )
		FE::Bucket( "40" )


		@if ( IsDeleted )
		{
			/* If the table is deleted from the model, we drop all views dependant on this table. */
			[
				ForEachReference( "Parent_Relationships_Ref" )
				{
					[
						/* Exclude views created during this session as they are not in the DB yet. */
						@ifnot ( IsCreated )
						{
							PushReference( "Child_Entity_Ref" )
							[ Equal( ObjectType, "View" )
								FE::Bucket("40")
								Execute( "Drop View" )
							]
							Pop
						}                   
					]
				}
			]

			/* We have to drop FK constraints before dropping the table */
			[
				ForEachReference( "Child_Relationships_Ref" )
				{
					[ PushReference( "Child_Entity_Ref" )
						[ Equal( ObjectType, "Entity" )
							Pop
							/* The current context is relationship. */
							[ 
								ForEachReference( "Dependent_Objects_Ref" )
								{
									Equal( ObjectType, "Key_Group" )
									Equal ( Left( Property( "Key_Group_Type" ), "2" ) , "IF"  )
									@ifnot( IsCreated )
									{
										Execute( "Drop Constraint" )
									}
								}                      
							]
							/* Repush child entity on the stack. */
							PushReference( "Child_Entity_Ref" )
						]
						Pop
					]
				}
			]

			/* Drop all FK constraints for relationships where the current entity is on the parent side. */           
			[
				ForEachReference( "Parent_Relationships_Ref" )
				{
					[ PushReference( "Parent_Entity_Ref" )
						[ Equal( ObjectType, "Entity" )
							Pop
							/* The current context is relationship. */
							[ 
								ForEachReference( "Dependent_Objects_Ref" )
								{
									Equal( ObjectType, "Key_Group" )
									Equal ( Left( Property( "Key_Group_Type" ), "2" ) , "IF"  )
									@ifnot ( IsCreated )
									{
										Execute( "Drop Constraint" )
									}
								}                      
							]
							/* Repush child entity on the stack. */
							PushReference( "Child_Entity_Ref" )
						]
						Pop
					]
				}
			]
		}

		/* Now we are ready drop the table. */
		FE::Bucket("40")
		"DROP TABLE " 
		[ < Execute( "Previous Owner" ) > "." ] 
		< Execute( "Previous Physical Name" ) >
		" CASCADE CONSTRAINTS" 
		[ DBMSVersion( "10" ) " PURGE" ] 
		FE::EndOfStatement
	]

]
SPItemEnd

SPItemBegin [keep format] = Drop Function
/* DESCRIPTION: Drop a function  during schema generation.  */
/* Assumes the context object is a function.		     	*/
[ 
	[ FE::Option( "TableDropFunctionSynonym" ) 
		FE::Bucket( "100" ) 
		ForEachOwnee( "Synonym" )
		{
			ShouldGenerate
			Execute( "Drop Synonym" )
		}
	]
	ShouldGenerate
	OnceForObject( [ Repush( "1" ) ObjectId Pop ] "Drop Function" )

	FE::Bucket( "105" )
	"DROP FUNCTION " [ <Execute( "Previous Owner" ) > "." ] Execute( "Previous Name" )
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Key_Group
/* DESCRIPTION: Drop an constraint/index  during schema generation.  */
/* Assumes the context object is a key group.		     	         */
[
	Set( "Owner Type", [ PushOwner ObjectType Pop ] )

	/* Make sure that the appropriate FE index option is selected. */
	Set( "Key_Group_Type", Left( Property( "Key_Group_Type" ), "2" ) )
	[ Equal( Value( "Owner Type" ), "Entity" )
			
		@if ( Equal( Value( "Key_Group_Type" ), "PK" ) )
		{
			FE::Option( "DropPKIndex" )
			SetLocalFlag( "Should Generate" )
		}
		@elseif ( Equal( Value( "Key_Group_Type" ), "AK" ) )
		{
			FE::Option( "DropAKIndex" )
			SetLocalFlag( "Should Generate" )
		}
		@elseif ( Equal( Value( "Key_Group_Type" ), "IF" ) )
		{
			FE::Option( "DropFKIndex" )
			SetLocalFlag( "Should Generate" )
		}
		@elseif ( Equal( Value( "Key_Group_Type" ), "IE" ) )
		{
			FE::Option( "DropIEIndex" )
			 SetLocalFlag( "Should Generate" )
		}
	]
	[ Equal( Value( "Owner Type" ), "Cached_View" )
		@if ( Equal( Value( "Key_Group_Type" ), "AK" ) )
		{
			FE::Option( "DropCachedViewAlternateKeyIndex" )
			SetLocalFlag( "Should Generate" )
		}
		@elseif ( Equal( Value( "Key_Group_Type" ), "IE" ) )
		{
			FE::Option( "DropCachedViewInversionEntryIndex" )
			SetLocalFlag( "Should Generate" )
		}			
	]
	Remove( "Key_Group_Type" )  

	[ FE::IsSchemaGeneration
		@if ( FE::Option( "DropFKIndex" ) )
		{
			Execute( "Drop Constraint" )
		}
		@if ( IsLocalFlagSet( "Should Generate" ) )
		{
			OnceForObject( "Drop Key_Group" )
			ShouldGenerate
			FE::Bucket( "40" )
			"DROP INDEX "  [ FE::OwnerOverride( "true" ) "." ] QuotedName
			FE::EndOfStatement
			ClearLocalFlag( "Should Generate" )
		}
	]

	[ FE::IsAlterScriptGeneration
		/* Generate 'drop index' only if key group had members. */
		@if ( IsPropertyModified ( "Index_Members_Order_Ref" ) )
		{
			PushOldImage
			@if ( IsPropertyNotNull( "Index_Members_Order_Ref" ) )
			{
				SetLocalFlag( "Key Group Had Members", "1" )
			}
			Pop
		}
		@else
		{
			@if ( IsPropertyNotNull( "Index_Members_Order_Ref" ) )
			{
				SetLocalFlag( "Key Group Had Members" )
			}
		}
		
		@if ( IsLocalFlagSet( "Key Group Had Members" ) )
		{
			@if ( Equal( Value( "Owner Type" ), "Entity" ) )
			{
				/* Was index unique? */
				/* TODO: the following if-else block needs to be revised. */
				@if ( IsPropertyModified( "Key_Group_Type" ) )
				{
					PushOldImage
					@if ( Equal( Left( Property( "Key_Group_Type" ), "2" ), "PK" ) )
					{ 
						SetLocalFlag( "Index Was Unique", "1" )
					}
					@elseif ( Equal( Left( Property( "Key_Group_Type" ), "2" ), "AK" ) )
					{
						SetLocalFlag( "Index Was Unique", "1" )
					}
					Pop
				}
				@else
				{
					@ifnot( IsCreated )
					{
						SetLocalFlag( "Index Was Unique" )
					}
				}					
	
				@if ( IsLocalFlagSet( "Index Was Unique" ) )
				{
					Execute( "Drop Constraint" )
				}
			}
			@elseif ( Equal( Value( "Owner Type" ), "View" ) )
			{
				Execute( "Drop Constraint" )
			}
	
			@if ( IsLocalFlagSet( "Should Generate" ) )
			{
				OnceForObject( "Drop Key_Group" )
				ShouldGenerate
				FE::Bucket( "40" )
				"DROP INDEX " [ < Execute( "Previous Owner" ) > "." ] <Execute( "Previous Physical Name" )>
				FE::EndOfStatement
				ClearLocalFlag( "Should Generate" )
			}
		}
	]
	Remove( "Owner Type" )
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Cached_View_Log
/* DESCRIPTION: Drop a Oracle cached view log during schema generation.   */
/* Assumes the context object is a Oracle cached view log.         */
[ ShouldGenerate
	OnceForObject( "Drop Cached View Log" )
	FE::Bucket( "40" ) 
	FE::Option( "TableDropMaterializedViewLog" )
	"DROP MATERIALIZED VIEW LOG ON " PushOwner  [ FE::OwnerOverride( "true" ) "." ][ Execute( "Previous Physical Name" ) ] Pop
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Cluster
/* DESCRIPTION: Drop a cluster during schema generation.   */
/* Assumes the context object is a Oracle cluster.         */

/* Drop cluster indexes first. */
[
	ForEachOwnee( "Oracle_Cluster_Index" )
	{
		@ifnot ( IsCreated )
		{
			Execute( "Drop Oracle_Cluster_Index" )
		}
	}
]

/* Drop the cluster. */
[ ShouldGenerate
	OnceForObject( "Drop Cluster" )
	FE::Option( "DropCluster" ) 
	FE::Bucket( "55" ) 
	"DROP CLUSTER " [ < Execute( "Previous Owner" ) > "." ] < Execute( "Previous Physical Name" ) >
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Cluster_Index
/* DESCRIPTION: Drop a cluster index during schema generation.   */
/* Assumes the context object is a Oracle cluster index.         */
[ ShouldGenerate
	OnceForObject( "Drop Cluster Index" )
	FE::Bucket( "55" ) 
	FE::Option( "DropClusterIndex" ) 
	"DROP INDEX " [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" ) 
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Constraint_State
/* DESCRIPTION: Drop Oracle constraint state during alter script generation.   */
/* Assumes the context object is a Oracle constraint state.                    */
[ PushOwner
	@ifnot ( IsDeleted )
	{
		/* Owner is not deleted in this session. */
		[ Equal( ObjectType, "Entity" ) Pop 
			[ Execute( "Generate Check_Constraint_Usage" ) ]
		]
		[ Equal( ObjectType, "Attribute" ) Pop 
			[ Execute( "Generate Check_Constraint_Usage" ) ]
		]
		[ Equal( ObjectType, "Key_Group" ) Pop 
				[ Execute( "Generate Key_Group" ) ]
		]
	}
	Pop
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Context
/* DESCRIPTION: Drop a context during schema generation.   */
/* Assumes the context object is a Oracle context.         */
[ ShouldGenerate
	OnceForObject( "Drop Oracle_Context" )
	FE::Bucket( "95" ) 
	FE::Option( "DropPackageContext" )  "DROP CONTEXT " < Execute( "Previous Name" ) >
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Database
/* DESCRIPTION: Drop a database during schema generation.   */
/* Assumes the context object is a Oracle database.         */
[
	[ FE::Bucket( "110" )
		FE::Option( "DropDatabaseTrigger" )
		<
			ForEachOwnee( "Trigger" )
			{
				ShouldGenerate
				Execute( "Drop Trigger" )
			}
		>
	]

	[ ShouldGenerate
		OnceForObject( "Drop Oracle_Database" )
		FE::Bucket( "10" )
		FE::Option( "DropDatabase" )
		"DROP DATABASE"
		FE::EndOfStatement
	]
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Database_Link
/* DESCRIPTION: Drop a database link during schema generation.   */
/* Assumes the context object is a Oracle database link.         */
[
	FE::IsSchemaGeneration
	ShouldGenerate
	OnceForObject( "Drop Oracle_Database_Link" )
	FE::Option( "DropDatabaseLink" )
	FE::Bucket( "20" )
	"DROP " 
	[ IsPropertyTrue( "Oracle_Is_Public" ) "PUBLIC " ] 
	"DATABASE LINK " < Execute( "Previous Physical Name" ) >
	FE::EndOfStatement
]
[ 
	FE::IsAlterScriptGeneration
	ShouldGenerate
	OnceForObject( "Drop Oracle_Database_Link" )
	FE::Option( "DropDatabaseLink" )
	FE::Bucket( "20" )
	"DROP " 
	
	/* Oracle Public property*/
	@if( IsPropertyModified( "Oracle_Is_Public" ) )
	{
		PushOldImage [ IsPropertyTrue( "Oracle_Is_Public" ) "PUBLIC " ] Pop
	}
	@else
	{ 
		IsPropertyTrue( "Oracle_Is_Public" ) "PUBLIC "
	}    
	"DATABASE LINK " < Execute( "Previous Physical Name" ) >
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Directory
/* DESCRIPTION: Drop a database link during schema generation.   */
/* Assumes the context object is a Oracle database link.         */
[ ShouldGenerate
	OnceForObject("Drop Oracle_Directory")    
	FE::Bucket( "15" ) FE::Option( "DropDirectory" ) 
	"DROP DIRECTORY "   < Execute( "Previous Physical Name" ) >  
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Disk_Group
/* DESCRIPTION: Drop a disk group during schema generation.   */
/* Assumes the context object is a Oracle disk group.         */
[ ShouldGenerate
	OnceForObject( "Drop Oracle_Disk_Group" )
	FE::Bucket( "5" ) FE::Option( "DropDiskgroup" )
	"DROP DISKGROUP " < Execute( "Previous Physical Name" ) > " INCLUDING CONTENTS"
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Library
/* DESCRIPTION: Drop a Oracle library during schema generation.   */
/* Assumes the context object is a Oracle library.                */
[ ShouldGenerate
	OnceForObject( "Drop Oracle_Library" )
	FE::Bucket( "25" ) 
	FE::Option( "DropLibrary" )
	"DROP LIBRARY "   [ < Execute( "Previous Owner" ) >"." ] Execute( "Previous Physical Name" )
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Package
/* DESCRIPTION: Drop a Oracle package during schema generation.   */
/* Assumes the context object is a Oracle package.                */
[ FE::Option( "DropPackageSynonym" )
	FE::Bucket( "95" ) 
	ForEachOwnee( "Synonym" )
	{
		ShouldGenerate
		Execute( "Drop Synonym" )
	}
]

/* Drop Oracle context. */
[
	ForEachOwnee( "Oracle_Context" )
	{
		Execute( "Drop Oracle_Context" )
	}
]

[ ShouldGenerate
	OnceForObject( "Drop Oracle_Package" )
	FE::Bucket( "95" ) 
	FE::Option( "DropPackage" )
	"DROP PACKAGE "  [ < Execute( "Previous Owner" ) > "." ] < Execute( "Previous Name" ) >
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Rollback_Segment
/* DESCRIPTION: Drop a Oracle rollback segment during schema generation.   */
/* Assumes the context object is a Oracle rollback segment.                */
[ ShouldGenerate
	OnceForObject( "Drop Oracle_Rollback_Segment" )
	FE::Bucket( "60" ) 
	FE::Option( "DropRollbackSeg" )
	"DROP "
	[ PushOldImage 
		[
			IsPropertyTrue( "Oracle_Is_Public" ) 
			"PUBLIC" 
		]
		Pop
	] 
	" ROLLBACK SEGMENT " < Execute( "Previous Name" ) > 
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Oracle_Tablespace
/* DESCRIPTION: Drop a Oracle tablespace during schema generation.   */
/* Assumes the context object is a Oracle tablespace.                */
[ ShouldGenerate
	OnceForObject( "Drop Oracle_Tablespace" )
	  
	FE::Bucket( "65" ) FE::Option( "DropTablespace" )
	"DROP TABLESPACE " < Execute( "Previous Physical Name" ) > 
	" INCLUDING CONTENTS " [ DBMSVersion( "9", "10" ) " AND DATAFILES " ] "CASCADE CONSTRAINTS" 
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Sequence
/* DESCRIPTION: Drop a Oracle sequence during schema generation.   */
/* Assumes the context object is a Oracle sequence.                */
[ FE::Option( "SequenceDropSynonym" ) 
	FE::Bucket( "35" )
	ForEachOwnee( "Synonym" )
	{
		ShouldGenerate
		Execute( "Drop Synonym" )
	}
]

[ ShouldGenerate
	OnceForObject( "Drop Sequence" )
	FE::Option( "DropSequence" ) 
	FE::Bucket( "35" )  
	"DROP SEQUENCE " [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" )
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Stored_Procedure
/* DESCRIPTION: Drop a procedure during schema generation.  */
/* Assumes the context object is a procedure.		     	*/
[ FE::Option( "TableDropProcedureSynonym" ) 
	FE::Bucket( "100" ) 
	ForEachOwnee( "Synonym" )
	{
		ShouldGenerate
		Execute( "Drop Synonym" )
	}
]
[ ShouldGenerate
	OnceForObject( [ Repush( "1" ) ObjectId Pop ] "Drop Stored_Procedure" )

	FE::Bucket( "100" )
	"DROP PROCEDURE " [ <Execute( "Previous Owner" ) > "." ] Execute( "Previous Name" )
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop Synonym
/* DESCRIPTION: Drop a synonym during schema generation.      */
/* Assumes the context object is a synonym.					  */
[
	ForEachOwnee( "Synonym" )
	{
		Execute( "Drop Synonym" )
	}
]

[ ShouldGenerate
	OnceForObject( "Drop Synonym" )

	[ FE::IsSchemaGeneration
		"DROP " [ IsPropertyTrue( "Oracle_Is_Public_Synonym" ) "PUBLIC " ]
		"SYNONYM " [ FE::OwnerOverride( "true" ) "." ]  QuotedName  [ DBMSVersion( "10" )" FORCE" ]
		FE::EndOfStatement
	]

	[ FE::IsAlterScriptGeneration
	   @ifnot(IsCreated)
		{
			"DROP " 
			[ 
				@if( IsPropertyModified( "Oracle_Is_Public_Synonym" ) )
				{
					PushOldImage [ IsPropertyTrue( "Oracle_Is_Public_Synonym" ) "PUBLIC " ] Pop
				}
				@else
				{
					IsPropertyTrue( "Oracle_Is_Public_Synonym" ) "PUBLIC "
				}
			]
			"SYNONYM " [ < Execute( "Previous Owner" ) > "." ]  Execute( "Previous Name" )  [ DBMSVersion( "10" )" FORCE" ]
			FE::EndOfStatement
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Drop Trigger
/* DESCRIPTION: Drop a trigger during schema generation.      */
/* Assumes the context object is a trigger.					  */
[ ShouldGenerate
	OnceForObject( "Drop Trigger" )
	FE::Bucket( "40" ) 
	"DROP TRIGGER "  [ < Execute( "Previous Owner") > "." ] Execute( "Previous Name" )
	FE::EndOfStatement
]
SPItemEnd

SPItemBegin [keep format] = Drop View
/* DESCRIPTION: Drop a view during schema generation.        */
/* Assumes the context object is a view.                     */ 
[ OnceForObject( "Drop View" )
	[ ShouldGenerate
		FE::Option( "ViewDropTrigger" )
		ForEachOwnee( "Trigger" )
		{
			ShouldGenerate
			Execute( "Drop Trigger" )
		}
	]

	[ ShouldGenerate
		FE::Option( "ViewDropSynonym" )
		FE::Bucket( "40" )
		ForEachOwnee( "Synonym" )
		{
			ShouldGenerate
			Execute( "Drop Synonym" )
		}
	]

	[ ShouldGenerate
		FE::Option( "DropView" )
		
		/* Drop all dependent views first. */
		[ FE::IsAlterScriptGeneration
			ForEachReference( "Parent_Relationships_Ref" )
			{
				PushReference( "Child_Entity_Ref" )
				[ Equal( ObjectType, "View" )
					Execute( "Drop View" )
				]
				Pop
			}
		]		

		/* Now we can drop this view. */
		FE::Bucket( "40" )
		"DROP VIEW " [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Name" ) " CASCADE CONSTRAINTS" 
		FE::EndOfStatement
	]
]
SPItemEnd

SPItemBegin [keep format] = Generate Cached_View
/* Assumes that the context is a cached view. */
[ Execute( "Drop Cached_View" ) ]
[ Execute( "Create Cached_View" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Check_Constraint_Usage
/* Assumes that the context is a check constraint usage. */
[ Execute( "Drop Check_Constraint_Usage" ) ]
[ Execute( "Create Check_Constraint_Usage" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Entity
/* DESCRIPTION: Recreate an entity during alter script generation.    */
/* Assumes the context object is an entity.                           */
[ OnceForObject( "Generate Entity" )

	/* Initialize data preservation function.                       */
	FE::ActivateDataPreservation

	/* Drop owned indexes. */
	[ FE::Bucket( "40" )
		ForEachOwnee( "Key_Group" )
		{
			Execute( "Drop Key_Group" )
		}
	]
	
	[
		ForEachOwnee( "Oracle_Cached_View_Log" )
		{
			[ ShouldGenerate
				@ifnot ( IsCreated )
				{
					Execute( "Drop Oracle_Cached_View_Log" )
				}
			]
		}
	]

	/* Are we dropping user defined table triggers? */
	[ FE::Option( "TableDropTrigger" )
		FE::Bucket( "40" )
		ForEachOwnee( "Trigger" )
		{
			[ ShouldGenerate
				Execute( "Drop Trigger" )
			]
		}
	]
	
	/* Are we dropping synonyms? */
	[ FE::Option( "TableDropSynonym" )
		FE::Bucket( "40" )
		ForEachOwnee( "Synonym" )
		{
			[ ShouldGenerate
				Execute( "Drop Synonym" )
			]
		}
	]

	[ FE::Option( "DropTable" )
		/* Drop all views depending on this table before dropping the table.                          */
		[
			ForEachReference( "Parent_Relationships_Ref" )
			{
				[
					/* Exclude views created during this session as they are not in the DB yet. */
					@ifnot ( IsCreated )
					{
						PushReference( "Child_Entity_Ref" )
						[ Equal( ObjectType, "View" )
							
							Execute( "Drop View" )
						]
						Pop
					}
				]
			}
		]
	
		/* Drop all FK constraints for relationships where the current entity is on the child side. */
		[
			ForEachReference( "Child_Relationships_Ref" )
			{
				[ PushReference( "Child_Entity_Ref" )
					[ Equal( ObjectType, "Entity" )
						Pop
						/* The current context is relationship. */
						[
							ForEachReference( "Dependent_Objects_Ref" )
							{
								Equal( ObjectType, "Key_Group" )
								Equal ( Left( Property( "Key_Group_Type" ), "2" ) , "IF"  )
								@ifnot ( IsCreated )
								{
									Execute( "Drop Constraint" )
								}
							}
						]
						PushReference( "Child_Entity_Ref" )
					]
					Pop
				]
			}
		]
	
		/* Drop all FK constraints for relationships where the current entity is on the parent side. */
		[
			ForEachReference( "Parent_Relationships_Ref" )
			{
				[ PushReference( "Parent_Entity_Ref" )
					Equal( ObjectType, "Entity" )
					Pop
					[
						ForEachReference( "Dependent_Objects_Ref" )
						{
							Equal( ObjectType, "Key_Group" )
							Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )
							[
								@ifnot ( IsCreated )
								{
									Execute( "Drop Constraint" )
								}
							]
						}
					]
					PushReference( "Parent_Entity_Ref" )
				]
				Pop
			}
		]

		[ FE::Bucket( "40" )
			/* Drop table-level check constraints. */
			[
				ForEachOwnee( "Check_Constraint_Usage" )
				{
					ListSeparator( "\n" )
					@ifnot( IsCreated )
					{
						"ALTER TABLE " PushOwner [ < Execute( "Previous Owner") > "." ] Execute( "Previous Physical Name" ) Pop 
						" DROP CONSTRAINT " < QuotedName >
						FE::EndOfStatement
					}
				}
			]

			/* Drop null and column-level check constraints. */
			[
				@if ( FE::Option( "ColumnPhysicalOrder" ) )
				{
					Set( "Column Order", "Physical_Columns_Order_Ref" )
				}
				@else
				{
					Set( "Column Order", "Columns_Order_Ref" )
				}
				
				ForEachReference( Value( "Column Order" ) )
				{
					ListSeparator( "\n" )
					[
						"ALTER TABLE " PushOwner [ < Execute( "Previous Owner") > "." ] Execute( "Previous Physical Name" ) Pop 
						" DROP CONSTRAINT " 
						[ FE::Option( "QuoteName" ) "\"" ] 
						<[
							<@if( IsPropertyModified("Null_Option_Constraint_Name") )
							{
								PushOldImage 
								Property( "Null_Option_Constraint_Name" )
 								Pop  
							}
							@else
							{
								Property( "Null_Option_Constraint_Name" )
							}>
						]>
						[ FE::Option( "QuoteName" ) "\"" ]
						FE::EndOfStatement
					]
					[
						ForEachOwnee( "Check_Constraint_Usage" )
						{
							ListSeparator( "\n" )
							@ifnot( IsCreated )
							{
								"ALTER TABLE " PushOwner PushOwner [ < Execute( "Previous Owner") > "." ] Execute( "Previous Physical Name" ) Pop  Pop
								" DROP CONSTRAINT " < QuotedName >
								FE::EndOfStatement
							}
						}
					]
				}
				Remove( "Column Order" )
			]

			/* Rename table with temporary name. */
			"ALTER TABLE "   [ < Execute( "Previous Owner" ) > "." ] Execute( "Previous Physical Name" )
			" RENAME TO " FE::TempTable( "Temporary" )
			FE::EndOfStatement
		]

	]


	/* Create entity. */
	Execute( "Create Entity" )


	/* Recreate dependent views. */
	[
		ForEachReference( "Parent_Relationships_Ref" )
		{
			[ PushReference( "Child_Entity_Ref" )
				[ Equal( ObjectType, "View" )
					@ifnot ( IsCreated )
					{
						Execute( "Create View" )
					}
				]
				Pop
			]
		}
	]


	/* Recreate FK constraints for relationships where this table is on the parent side. */
	[
		/* TODO: Review this code. */
		ForEachReference( "Parent_Relationships_Ref" )
		{
			[   PushReference( "Parent_Entity_Ref" )
				[ Equal( ObjectType, "Entity" )
					Pop
					[ 
						ForEachReference( "Dependent_Objects_Ref" )
						{
							Equal( ObjectType, "Key_Group" )
							Equal( Left( Property( "Key_Group_Type" ), "2" ), "IF" )
							@ifnot ( IsCreated )
							{
								Execute( "Create Constraint" )
							}
						}
					]
					PushReference( "Parent_Entity_Ref" )    
				]
				Pop
			]
		}
	]

	/* Copy data from the temporary table into the newly created one */
	/* if PreserveData option is turned on.                          */

	/* Now we can drop the temporary table.                         */
	@if ( IsPropertyEqual( "Data_Organization_Type", "913" ) )
	{
		FE::Bucket( "140" ) "\n"
		"/* DML operations cannot be performed on External table */ \n"
		"/* So for External Table " QuotedName ", Load Data From Temporary Table " FE::TempTable( "Temporary" ) "*/ \n"
		"/* Warning - Drop Temporary Table After Load Of Data*/" "\n"
		"/* For dropping, use this script- DROP TABLE " FE::TempTable( "Temporary" )" CASCADE CONSTRAINTS*/ \n"
		FE::EndOfStatement
	}
	@else
	{
		[ FE::DataPreservationOption( "PreserveData" )
			FE::Bucket( "93" ) 
			
			/* Prepare the insert query for the data preservation. */
			"INSERT INTO " [ FE::OwnerOverride( "true" ) "." ] QuotedName
			" ("
			<
				ForEachReference( "Columns_Order_Ref" )
				{
					NotEqual( ConversionFunction, "" )
					ListSeparator( ", " )
					QuotedName
				}
			>
			") SELECT "
			<
				ForEachReference( "Columns_Order_Ref" )
				{
					NotEqual( ConversionFunction, "" )
						ListSeparator( ", " )
						ConversionFunction
				}
			>
			" FROM " [ < Execute( "Previous Owner" ) > "." ]  FE::TempTable( "Temporary" )
			[ " WHERE " FE::DataPreservationOption( "WhereClause" ) ]
			FE::EndOfStatement
		]
		[ FE::DataPreservationOption( "DropTempTable" )
			FE::Bucket( "140" )  
			"DROP TABLE " [ < Execute( "Previous Owner" ) > "." ] FE::TempTable( "Temporary" )
			" CASCADE CONSTRAINTS" [ DBMSVersion( "10" )" PURGE" ]
			FE::EndOfStatement
		]
	}
]
SPItemEnd

SPItemBegin [keep format] = Generate Function
/* Assumes that the context is a function. */
[ Execute( "Drop Function" ) ]
[ Execute( "Create Function" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Key_Group
/* DESCRIPTION: Recreate an index  during alter script generation.    */
[
	Execute( "Drop Key_Group" )
	Execute( "Create Key_Group" )
]
SPItemEnd

SPItemBegin [keep format] = Generate Model
/* DESCRIPTION: Recreate model-level objects.                   */
/* Assumes the context object is a model-level object like      */
/* pre(post)-script, stored procedure or function.              */

[
	/* Is the "TablePreScript" option turned on?   */ 
	[ FE::Option( "ModelPreScript" )
		FE::IsSchemaGeneration
		ForEachOwnee( "Script_Template", "Object_Order" )
		{
			[ ShouldGenerate IsPropertyTrue( "Generate_As_Pre_Script" )
				FE::Bucket( "1" )
				Equal( Property( "Type" ), "Model Level" )
                FE::ExpandERwinMacro( "Template_Code" )
				FE::EndOfStatement( "true" )
			]
		}
	]
	
	/* Model-level stored procedures, functions and packages. */
	[ FE::IsSchemaGeneration
		[
			ForEachReference( "Source_Objects_Ref" )
			{
				ShouldGenerate
				[ Equal( ObjectType, "Stored_Procedure" )
					Equal( Property( "Type" ), "Model Level" )
					[ FE::Option( "ModelDropProcedureSynonym" ) 
						FE::Bucket( "100" ) 
						ForEachOwnee( "Synonym" )
						{
							ShouldGenerate
							Execute( "Drop Synonym" )
						}
					]
					[ FE::Option( "ModelDropProcedure" ) Execute( "Drop Stored_Procedure" ) ]
					[ FE::Option( "ModelCreateProcedure" ) Execute( "Create Stored_Procedure" ) ]
					[ FE::Option( "ModelCreateProcedureSynonym" )
						FE::Bucket( "100" )
						ForEachOwnee( "Synonym" )
						{
							ShouldGenerate
							Execute( "Create Synonym" )
						}
					]
				]
				[ Equal( ObjectType, "Function" )
					Equal( Property( "Type" ), "Model Level" )
					[ FE::Option( "DropFunctionSynonym" ) 
						FE::Bucket( "105" ) 
						ForEachOwnee( "Synonym" )
						{
							ShouldGenerate
							Execute( "Drop Synonym" )
						}
					]
					[ FE::Option( "ModelDropFunction" ) Execute( "Drop Function" ) ]
					[ FE::Option( "ModelCreateFunction" ) Execute( "Create Function" ) ]
					[ FE::Option( "CreateFunctionSynonym" )
						FE::Bucket( "105" )
						ForEachOwnee( "Synonym" )
						{
							ShouldGenerate
							Execute( "Create Synonym" )
						}
					]
				]

				[ Equal( ObjectType, "Oracle_Package" )
					Execute( "Generate Oracle_Package" )
				]
			}
		]
	]

	/* Is the "TablePostScript" option turned on?   */ 
	[ FE::Option( "ModelPostScript" )
		FE::IsSchemaGeneration
		ForEachOwnee( "Script_Template", "Object_Order" )
		{
			[ ShouldGenerate IsPropertyFalse( "Generate_As_Pre_Script" )
				FE::Bucket( "120" )
				Equal( Property( "Type" ), "Model Level" )
                FE::ExpandERwinMacro( "Template_Code" )
				FE::EndOfStatement( "true" )
			]
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Cached_View_Log
/* Assumes that the context is a Oracle cached view log. */
[ ShouldGenerate
	Execute( "Drop Oracle_Cached_View_Log" )
]
[ ShouldGenerate
	Execute( "Create Oracle_Cached_View_Log" )
]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Cluster
/* Assumes that the context is a Oracle cluster. */
[ ShouldGenerate
	Execute( "Drop Oracle_Cluster" )
]
[ ShouldGenerate
	Execute( "Create Oracle_Cluster" )
]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Cluster_Index
/* Assumes that the context is a Oracle cluster index. */
[ ShouldGenerate
	Execute( "Drop Oracle_Cluster_Index" )
]
[ ShouldGenerate
	Execute( "Create Oracle_Cluster_Index" )
]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Context
/* Assumes that the context is a Oracle context object. */
[ Execute( "Drop Oracle_Context" ) ]
[ Execute( "Create Oracle_Context" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Database
/* Assumes that the context is a Oracle databse object. */
[  Execute( "Drop Oracle_Database" ) ]
[  Execute( "Create Oracle_Database" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Database_Link
/* Assumes that the context is a Oracle databse link object. */
[  Execute( "Drop Oracle_Database_Link" ) ]
[  Execute( "Create Oracle_Database_Link" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Directory
/* Assumes that the context is a Oracle directory object. */
[ Execute( "Drop Oracle_Directory" ) ]
[ Execute( "Create Oracle_Directory" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Disk_Group
/* Assumes that the context is a Oracle disk group. */
[ FE::Bucket( "5" )  Execute( "Drop Oracle_Disk_Group" ) ]
[ FE::Bucket( "5" ) Execute( "Create Oracle_Disk_Group" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Library
/* Assumes that the context is a Oracle library. */
[ Execute( "Drop Oracle_Library" ) ]
[ Execute( "Create Oracle_Library" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Package
/* Assumes that the context is a Oracle package. */
[ Execute( "Drop Oracle_Package" ) ]
[ Execute( "Create Oracle_Package" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Rollback_Segment
/* Assumes that the context is a Oracle rollback segment. */
[ Execute ( "Drop Oracle_Rollback_Segment" ) ]
[ Execute ( "Create Oracle_Rollback_Segment" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Oracle_Tablespace
/* Assumes that the context is a Oracle tablespace. */
[ Execute( "Drop Oracle_Tablespace" ) ]
[ Execute( "Create Oracle_Tablespace" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Sequence
/* Assumes that the context is a Oracle sequence. */
[ Execute( "Drop Sequence" ) ]
[ Execute( "Create Sequence" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Stored_Procedure
/* Assumes that the context is a stored procedure. */
[ Execute( "Drop Stored_Procedure" ) ]
[ Execute( "Create Stored_Procedure" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate Synonym
/* Assumes that the context is a synonym. */
[ FE::Bucket( "35" ) 
	FE::Option( "ModelDropSynonym" )
	Execute( "Drop Synonym" )
]
[ FE::Bucket( "35" )  
	FE::Option( "ModelCreateSynonym" ) 
	Execute( "Create Synonym" )  
]
SPItemEnd

SPItemBegin [keep format] = Generate Trigger
/* Assumes that the context is a trigger. */
[ Execute( "Drop Trigger" ) ]
[ Execute( "Create Trigger" ) ]
SPItemEnd

SPItemBegin [keep format] = Generate View
/* Assumes that the context is a view. */
[ Execute( "Drop View" ) ]
[ Execute( "Create View" ) ]
SPItemEnd

SPItemBegin [keep format] = Key Group Members
/* Assumes that the context is a key group.    */
[
	ForEachReference( "Index_Members_Order_Ref" )
	{
		ListSeparator( "," )
		@if ( IsPropertyNotNull( "Attribute_Ref" ) )
		{
			QuotedName
		}
		@else
		{
			Property( "Expression" )
		}
		[ "   " Property( "Key_Group_Sort_Order", "no_translate" ) ]
	}
]
SPItemEnd

SPItemBegin [keep format] = Previous Name
/* DESCRIPTION: Fetch an old name of the object.               */
/* Assumes the context object is any object.                   */
[ FE::IsSchemaGeneration
	QuotedName
]

[ FE::IsAlterScriptGeneration
	@if ( IsPropertyModified( "Name" ) )
	{
		PushOldImage QuotedName Pop
	}
	@else
	{
		QuotedName
	}
]
SPItemEnd

SPItemBegin [keep format] = Previous Owner
/* DESCRIPTION: Fetch an old DB owner of the object.           */
/* Assumes the context object is any object.                   */
[ FE::Option( "SpecifyOwner" )

	[ FE::IsSchemaGeneration
		FE::OwnerOverride( "true" ) 
	]

	[ FE::IsAlterScriptGeneration
		/* By default, we are reading DB owner from the model. */
		SetLocalFlag( "Default To Model" )
	
		/* Is DB owner overriden by the user?                            */
		/* FE::OwnerOverride will emit the owner name if it's overriden. */
		@if ( FE::OwnerOverride )
		{
			ClearLocalFlag( "Default To Model" )
		}
	
		@if ( IsLocalFlagSet( "Default To Model" ) )
		{
			/* Fetch the DB owner from the model.                         */
			@if ( IsPropertyModified( "Schema_Name" ) )
			{
				PushOldImage
				Property( "Schema_Name" )
				Pop
			}
			@else
			{
				Property( "Schema_Name" )
			}
			
			ClearLocalFlag( "Default To Model" )
		}
	]
]
SPItemEnd

SPItemBegin [keep format] = Previous Physical Name
/* DESCRIPTION: Fetch an old physical name of the object.      */
/* Assumes the context object is any object.                   */

[ FE::IsSchemaGeneration
	QuotedName
]

[ FE::IsAlterScriptGeneration
	@if ( IsPropertyModified( "Name", "Physical_Name" ) )
	{
		PushOldImage QuotedName Pop
	}
	@else
	{
		QuotedName
	}
]
SPItemEnd

SPItemBegin [keep format] = Previous Property Value
/* DESCRIPTION: Fetch an old property value .            */
/* Assumes the context object is any object.             */
/* This is a parameterized template: %1 will be replaced */
/* with the property name.                               */
[ FE::IsSchemaGeneration
	Property( "%1" )
]

[ FE::IsAlterScriptGeneration
	@if ( IsPropertyModified( "%1" ) )
	{
		PushOldImage Property( "%1" ) Pop
	}
	@else
	{
		Property( "%1" )
	}
]
SPItemEnd

